<!DOCTYPE html>
<html>
    <head>
        <title>Blog - Doctrine - PHP Database Tools</title>

        <meta charset="utf-8">
        <meta name="theme-color" content="#ffffff">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

                    <meta name="robots" content="noindex, follow">
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.8/css/all.css" integrity="sha384-3AB7yXWz4OeoZcPbieVW64vVXEwADiYyAEhwilzWsLw+9FgqpyjjStpPnpBO8o8S" crossorigin="anonymous">

        <link href="https://staging.doctrine-project.org/css/style.css?369e38" rel="stylesheet" type="text/css" />

        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0/dist/instantsearch.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0/dist/instantsearch-theme-algolia.min.css">

        <link rel="stylesheet" href="https://staging.doctrine-project.org/components/highlightjs/styles/railscasts.css?b4f8ae" />

        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">

        <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://staging.doctrine-project.org/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://staging.doctrine-project.org/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://staging.doctrine-project.org/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://staging.doctrine-project.org/images/apple-touch-icon-144x144.png" />
        <link rel="apple-touch-icon-precomposed" sizes="60x60" href="https://staging.doctrine-project.org/images/apple-touch-icon-60x60.png" />
        <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://staging.doctrine-project.org/images/apple-touch-icon-120x120.png" />
        <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://staging.doctrine-project.org/images/apple-touch-icon-76x76.png" />
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://staging.doctrine-project.org/images/apple-touch-icon-152x152.png" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-128.png" sizes="128x128" />
        <meta name="application-name" content="Doctrine"/>
        <meta name="msapplication-TileColor" content="#FFFFFF" />
        <meta name="msapplication-TileImage" content="https://staging.doctrine-project.org/images/mstile-144x144.png" />
        <meta name="msapplication-square70x70logo" content="https://staging.doctrine-project.org/images/mstile-70x70.png" />
        <meta name="msapplication-square150x150logo" content="https://staging.doctrine-project.org/images/mstile-150x150.png" />
        <meta name="msapplication-wide310x150logo" content="https://staging.doctrine-project.org/images/mstile-310x150.png" />
        <meta name="msapplication-square310x310logo" content="https://staging.doctrine-project.org/images/mstile-310x310.png" />

        <meta property="og:image" content="https://staging.doctrine-project.org/images/og.png" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="1200" />

        <link rel="alternate" type="application/atom+xml" href="https://staging.doctrine-project.org/atom.xml" title="Doctrine activity feed" />

        
            </head>
    <body>
                    <nav class="navbar navbar-expand-md navbar-dark sticky-top bg-dark flex-md-nowrap">
                <a class="navbar-brand text-hide" href="https://staging.doctrine-project.org/"><img src="https://staging.doctrine-project.org/images/doctrine-logo.svg?335f0f" />Doctrine</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarCollapse">
                    <ul class="navbar-nav mr-auto">
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="https://staging.doctrine-project.org/projects/" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                Projects
                            </a>
                            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/annotations/">Annotations</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/cache/">Cache</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/collections/">Collections</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/common/">Common</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/couchdb-odm/">CouchDB ODM</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/dbal/">DBAL</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/inflector/">Inflector</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/lexer/">Lexer</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/migrations/">Migrations</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/mongodb/">MongoDB</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/mongodb-odm/">MongoDB ODM</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/orientdb-odm/">OrientDB ODM</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/orm/">ORM</a>
                                                                    <a class="dropdown-item" href="https://staging.doctrine-project.org/projects/phpcr-odm/">PHPCR ODM</a>
                                                            </div>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/about/">About</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/contribute/">Contribute</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/community/">Community</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://staging.doctrine-project.org/blog/">Blog</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/team/">Team</a>
                        </li>
                    </ul>

                    <div id="search-box">
                        <!-- SearchBox widget will appear here -->
                    </div>
                </div>

                <div class="search-results rounded">
                    <div id="hits">
                        <!-- Hits widget will appear here -->
                    </div>

                    <a href="https://www.algolia.com" target="_blank"><img src="https://staging.doctrine-project.org/images/search-by-algolia.png" class="float-right" style="width: 150px;" /></a>
                </div>
            </nav>
        
            <main role="main" class="container-wrapper container">
                        <article>
        <header>
            <h2><a href="https://staging.doctrine-project.org/2010/07/19/your-own-orm-doctrine2.html">Write your own ORM on top of Doctrine2</a></h2>
        </header>

        <p class="lead">
            Posted on 2010-07-19
                            by
                                    beberlei
                                    </p>

        <hr />

        <div>
            <p><strong>NOTE</strong></p>
<blockquote><p>The Doctrine ActiveEntity Extension is just an experiment, nothing
that will be developed much further from the Doctrine Dev Team. It
is only a show-case for what is possible with Doctrine2. Please
feel free to take the code and develop it further.</p>
</blockquote>
<p>Did you feel the urge to write your own Object-Relational Mapper
after reading Martin Fowlers PoEAA? I am guilty to have tried
implementing two different ORMs on my own, both now safely dumped
into the trash.</p>
<p>In isolation each ORM pattern is easy to describe, understand and
even implement. However the combination of a large set of patterns
into a single implementation introduces a lot of hard to solve
complexity in your code. Even simple Object-Relational-Mappers
require a lot of patterns to become useful: Metadata Mapping,
Identity Map, Foreign Key Mapping, Association Table Mapping and
Query Object. Implementations with more features at least need the
UnitOfWork and probably many more, for example handling
inheritance, locking, value objects and such.</p>
<p>Doctrine2 already solves a lot of the head aching problems in a
consistent approach. We have been working on this project for
almost 2 years now, with all the experience we gained implementing
Doctrine 1. Additionally we make use of well-understood concepts
from other ORM implementations across various languages.</p>
<p>We as developers think that Doctrine2 responsibilities are very
well separated such that you can exchange larger parts of the
Doctrine2 core without having to re-implement everything. So if you
ever feel inspired to implement your own ORM, we would be happy to
offer you Doctrine2 as a foundation to build upon.</p>
<p>There are examples of other ORMs that have taken the re-use instead
of re-implement road. For example the
<a href="http://www.grails.org/GORM">Groovy Grails ORM</a> is an
ActiveRecord implementation on top of the popular Hibernate Java
ORM. Since Groovy is a java-virtual-machine language it can safely
use the Hibernate ORM as a dependent library.</p>
<p>This article will describe some possible extensions and show where
you can hook into the Doctrine2 core to implement your own ORM. The
article will be very code focused and also comes with a
<a href="http://github.com/beberlei/Doctrine-ActiveEntity">Github project</a>
where all the code and some tests are hosted.</p>
<a id="title.1"></a><h1>Doctrine2 and ActiveRecord</h1>
<p>Doctrine2 is implementing the DataMapper pattern, however many
programmers think ActiveRecord is better for various reasons. For
me data-mappers are superiour to ActiveRecord, however I do
understand why ActiveRecord is so popular: Its very easy to get
started and do cool stuff with it! If you want Doctrine2 to be
ActiveRecord you can have it. Actually it is very easy to turn it
into a powerful ActiveRecord implementation, keeping all the
powerful features such as DQL.</p>
<p>Some while ago Jonathan already released his approach, called the
&quot;ActiveEntity&quot; extension. Its a single abstract php class that your
entities have to implement, the code is still
<a href="http://trac.doctrine-project.org/browser/extensions/ActiveEntity/branches/2.0-1.0/DoctrineExtensions/ActiveEntity.php">in our SVN repository</a>.
However a more recent version of this code is available as
<a href="http://github.com/beberlei/Doctrine-ActiveEntity">a project on Github</a>.
I won't support this experiment any further, I hope somebody picks
it up and starts maintaining it.</p>
<p>With Jonathans old code, to allow active record entities, you have
to bootstrap the ActiveEntity by passing a static EntityManager:</p>
<pre><code class="php">&lt;?php
\DoctrineExtensions\ActiveEntity::setEntityManager($em);
</code></pre>
<p>Now say we have a User Entity (using Jonathans old ActiveEntity):</p>
<pre><code class="php">&lt;?php
namespace Entities;

use DoctrineExtensions\ActiveEntity;

/** @Entity */
class User extends ActiveEntity
{
    /** @Id @GeneratedValue @column(type=&quot;integer&quot;) */
    private $id;

    /** @Column(type=&quot;string&quot;) */
    private $name;
}
</code></pre>
<p>With PHP 5.3 late-static binding functionality we can now access
the <code>EntityRepository</code>, a finder object for entities using a Ruby
on Rails'ish notation:</p>
<pre><code class="php">&lt;?php
$user = User::find($id);
$users = User::findBy(array(&quot;name&quot; =&gt; &quot;beberlei&quot;));
$beberlei = User::findOneBy(array(&quot;name&quot; =&gt; &quot;beberlei&quot;));
</code></pre>
<p>The code to allow this functionality is very simple:</p>
<pre><code class="php">&lt;?php
public static function __callStatic($method, $arguments)
{
    return call_user_func_array(array(self::$_em-&gt;getRepository(get_called_class()), $method), $arguments);
}
</code></pre>
<p>There are also some additional methods on the <code>ActiveEntity</code>
class that use magic <strong>get and</strong>set and \_\_call methods to access
the private properties of an Entity (such as the User id and name
shown above). Additionally you can call save() or remove() on any
instance.</p>
<p>For starters this offers a great ActiveRecord implementation with
all the powerful features that Doctrine2 offers, such as DQL and
UnitOfWork. However we can still go much further:</p>
<ul><li class="dash"> Eliminate the need to define ActiveEntity properties by metadata
   mapping inference</li>
<li class="dash"> Adding your own powerful Metadata Mapping Layer</li>
<li class="dash"> Add a Doctrine 1.2 behaviour system using the PHP 5.3.99DEV
   Traits functionalitiy</li>
<li class="dash"> Add validation to properties of an ActiveEntity</li>
</ul>

<p>Lets begin with a simple introduction to the Doctrine Metadata
Model to explain how this is all possible.</p>
<a id="title.2"></a><h1>Doctrine2 Metadata Model</h1>
<p>You probably already saw that Doctrine2 offers many different
metadata configuration mechanisms: Annotations, YAML, XML and plain
PHP. Any one of this implementations will transform into an
instance of <code>Doctrine\ORM\ClassMetadata</code> which is then cached for
subsequent web requests. The <code>ClassMetadataFactory</code> is
responsible for creating and managing those metadata instances.</p>
<p>Doctrine2 uses the <code>ClassMetadata</code> instance internally for all
runtime access to your entities metadata, which means that you have
to extend this class such that it works exactly the same from the
outside.</p>
<p>If you wanted to extend the inner workings of Doctrine2, this is
indeed the way to go. First extend the EntityManager to replace the
<code>ClassMetadataFactory</code> used. This piece of code is the only
hackish workaround, everything else is rather nice :-)</p>
<pre><code class="php">&lt;?php
namespace DoctrineExtensions\ActiveEntity;

use DoctrineExtensions\ActiveEntity\Mapping\ClassMetadataFactory;

class ActiveEntityManager extends \Doctrine\ORM\EntityManager
{
    protected function __construct(Connection $conn, Configuration $config, EventManager $eventManager)
    {
        parent::__construct($conn, $config, $eventManager);

        $metadataFactory = new ActiveClassMetadataFactory($this);
        $metadataFactory-&gt;setCacheDriver($this-&gt;getConfiguration()-&gt;getMetadataCacheImpl());

        // now this is the only hack required to get it work:
        $reflProperty = new \ReflectionProperty('Doctrine\ORM\EntityManager', 'metadataFactory');
        $reflProperty-&gt;setAccessible(true);
        $reflProperty-&gt;setValue($this, $metadataFactory);
    }

    public static function create($conn, Configuration $config, EventManager $eventManager = null)
    {
        // ... copy paste from EntityManager::create()

        return new ActiveEntityManager($conn, $config, $conn-&gt;getEventManager());
    }
}
</code></pre>
<p>And both the <code>ClassMetadataFactory</code> and <code>ClassMetadata</code>:</p>
<pre><code class="php">&lt;?php
namespace DoctrineExtensions\ActiveEntity\Mapping;

class ActiveClassMetadataFactory extends \Doctrine\ORM\Mapping\ClassMetadataFactory
{
    protected function _newClassMetadataInstance($className)
    {
        return new ActiveClassMetadata($className);
    }
}

class ActiveClassMetadata extends \Doctrine\ORM\Mapping\ClassMetadata
{
}
</code></pre>
<p>This is the foundation of your own Doctrine2-based ORM. We will see
in the next section how we can use this.</p>
<a id="title.3"></a><h1>Exchange Doctrine2 Reflection for Array-based Field Storage</h1>
<p>Doctrine2 uses reflection to access the current values of an
entity. This is necessary, because Doctrine2 is a Data Mapper that
enforces clean separation between entities and persistence. If we
extend it to be an ActiveRecord implementation this separation is
not wanted anymore and we can opt for a new approach, using the
get()/set() methods on our ActiveEntities.</p>
<p>Defining the properties &quot;id&quot; and &quot;name&quot; will then not be necessary
anymore, they will all be saved in an array hash-map called
&quot;\_data&quot; inside the ActiveEntity. We cannot use annotations for
metadata anymore, however the XML or YAML drivers would still work
smoothly.</p>
<p>To get started we have to modify our <code>ActiveClassMetadata</code> a bit
to exchange the contents of reflClass and reflFields with our own
classes. Looking at the <code>ClassMetadata</code> code and doing some
project wide searches I found out about all the necessary changes.
To replace the <code>ReflectionClass</code> we only need to exchange
<code>getProperty</code> and keep the rest. To exchange
<code>ReflectionProperty</code> we only have to overwrite
<code>setAccessible()</code>, <code>getValue()</code> and <code>setValue()</code>.</p>
<pre><code class="php">&lt;?php
namespace DoctrineExtensions\ActiveEntity\Reflection;

class ActiveEntityReflectionClass extends \ReflectionClass
{
    public function getProperty($name)
    {
        return new ActiveEntityPropertyReflection($this-&gt;name, $name);
    }
}

class ActiveEntityReflectionProperty
{
    public $name = null;
    public $class = null;

    public function __construct($class, $name)
    {
        $this-&gt;class = $class;
        $this-&gt;name = $name;
    }

    public function setAccessible($flag) {}

    public function setValue($entity = null, $value = null)
    {
        $entity-&gt;set($this-&gt;name, $value);
    }

    public function getValue($entity = null)
    {
        return $entity-&gt;get($this-&gt;name);
    }
}
</code></pre>
<p>This is about enough to exchange reflection transformation against
a simple ActiveRecord get/set approach. Now we need to replace the
all the instantiations of <code>ReflectionClass</code> relevant for runtime
mapping with our implementation:</p>
<pre><code class="php">&lt;?php
namespace DoctrineExtensions\ActiveEntity\Mapping;

use DoctrineExtensions\ActiveEntity\Reflection\ActiveEntityReflectionClass;
use DoctrineExtensions\ActiveEntity\Reflection\ActiveEntityReflectionProperty;

class ActiveClassMetadata extends \Doctrine\ORM\Mapping\ClassMetadata
{
    public function __construct($entityName)
    {
        parent::__construct($entityName);
        $this-&gt;reflClass = new ActiveEntityReflectionClass($entityName);
        $this-&gt;namespace = $this-&gt;reflClass-&gt;getNamespaceName();
        $this-&gt;table['name'] = $this-&gt;reflClass-&gt;getShortName();
    }

    /**
     * Restores some state that can not be serialized/unserialized.
     *
     * @return void
     */
    public function __wakeup()
    {
        // lots of code here, see the Github Repository
    }
}
</code></pre>
<p>Again, this is enough and our ActiveEntity Mapping now works. We
can heavily modify the <code>ActiveEntity</code> now to loose the
requirement to specify properties for the defined metadata. We can
rewrite the User entity to be:</p>
<pre><code class="php">&lt;?php
namespace Entities;

use DoctrineExtensions\ActiveEntity\ActiveEntity;

class User extends ActiveEntity
{
}
</code></pre>
<p>Using an XML or YAML Mapping is already enough for this
ActiveEntity to work out of the box.</p>
<a id="title.4"></a><h1>Implementing your own Metadata Mapping Driver</h1>
<p>In the spirit of Doctrine 1.\* or GORM there should be a PHP based
metadata mapping driver now and actually Doctrine2 ships with one
already:</p>
<pre><code class="php">&lt;?php
$config = new \Doctrine\ORM\Configuration();
$config-&gt;setMetadataDriverImpl(new \Doctrine\ORM\Mapping\Driver\StaticPHPDriver());
// ...
</code></pre>
<p>This allows to specify the metadata within the User class:</p>
<pre><code class="php">&lt;?php
namespace Entities;

use DoctrineExtensions\ActiveEntity\ActiveEntity;
use DoctrineExtensions\ActiveEntity\Mapping\ActiveClassMetadata;

class User extends ActiveEntity
{
    static public function loadMetadata(ActiveClassMetadata $cm)
    {
        // work with $cm here!
    }
}
</code></pre>
<p>You could extend that Static PHP Driver even more for the next
section. We could add additional metadata information, such as
names of behaviours to extend or validators or anything else.</p>
<a id="title.5"></a><h1>Using Traits for Behaviours</h1>
<p>We want to add a simple &quot;Timestampable&quot; behaviour now, hooking into
the <code>loadClassMetadata</code> event
<a href="http://www.doctrine-project.org/projects/orm/2.0/docs/reference/events/en#load-classmetadata-event">as described in the documentation</a>:</p>
<p>Now this is untested code, as i don't have a PHP-5.3.99-DEV version
compiled at this machine.</p>
<p>The following trait can be used by our <code>User</code> entity:</p>
<pre><code class="php">&lt;?php
namespace DoctrineExtensions\ActiveEntity\Behaviour;

trait Timestampable
{
    public function created()
    {
        return $this-&gt;get('created');
    }

    public function updated()
    {
        return $this-&gt;get('updated');
    }

    /** will be a prePersist lifecycle hook */
    public function setCreated()
    {
        return $this-&gt;set('created', new \DateTime(&quot;now&quot;));
    }

    /** will be a preUpdate lifecycle hook */
    public function setUpdated()
    {
        return $this-&gt;set('updated', new \DateTime(&quot;now&quot;));
    }
}

class User extends ActiveEntity use Timestampable
{

}
</code></pre>
<p>We now need an Event that modifies the <code>ActiveClassMetadata</code> as
required:</p>
<pre><code class="php">&lt;?php
namespace DoctrineExtensions\ActiveEntity\Behaviour;

use Doctrine\ORM\Event\LoadClassMetadataEventArgs;

class TimestampableEvent
{
    public function loadClassMetadata(LoadClassMetadataEventArgs $eventArgs)
    {
        $classMetadata = $eventArgs-&gt;getClassMetadata();
        $traits = $classMetadata-&gt;reflClass-&gt;getTraitNames();
        if (!in_array(&quot;DoctrineExtensions\ActiveEntity\Behaviour\Timestampable&quot;, $traits)) {
            return;
        }

        $classMetadata-&gt;mapField(array(
            'type' =&gt; 'datetime',
            'fieldName' =&gt; 'created',
        ));
        $classMetadata-&gt;mapField(array(
            'type' =&gt; 'datetime',
            'fieldName' =&gt; 'updated',
        ));
        $classMetadata-&gt;addLifecycleCallback(&quot;prePersist&quot;, &quot;setCreated&quot;);
        $classMetadata-&gt;addLifecycleCallback(&quot;prePersist&quot;, &quot;setUpdated&quot;);
        $classMetadata-&gt;addLifecycleCallback(&quot;preUpdate&quot;, &quot;setUpdated&quot;);
    }
}
</code></pre>
<p>You can now register this behaviour with your Entity Manager and
just the usage of the trait <code>Timestampable</code> adds two additional
fields and updates them accordingly.</p>
<blockquote><p><strong>NOTE</strong></p>
<p>Again, the trait code is untested. It should work, but I cannot
guarantee! :)</p>
</blockquote>
<a id="title.6"></a><h1>Conclusion</h1>
<p>What are you waiting for? This article showed a very deep
modification of the Doctrine2 core to turn it into Active Record.
The changes required some understanding of the inner workings of
Doctrine2, however not many changes were required in the end.</p>
<p><a href="http://github.com/beberlei/Doctrine-ActiveEntity">See the code on GitHub!</a></p>

        </div>

            </article>
    <article>
        <header>
            <h2><a href="https://staging.doctrine-project.org/2010/07/12/doctrine2-large-collections.html">Working with Large Collections in Doctrine2</a></h2>
        </header>

        <p class="lead">
            Posted on 2010-07-12
                            by
                                    beberlei
                                    </p>

        <hr />

        <div>
            <p>If you access a collection of Entity A pointing to Entity B,
Doctrine2 always initializes the complete collection for you. For
small collections up to around 100 entities this won't be a
problem, however as soon as collections get (much) bigger than this
you can get into serious trouble.</p>
<p>By default Doctrine2 can only optimize adding new entities to a
collection for you. This operation does not initialize the
collection. This will only get you bigger collections though,
reading them is still a pain.</p>
<p>We already got requests from several development teams for better
functionality in this regard and we are planning to add a solution
to this problem that is not constraining your domain model with
technical blurp. However this solution is currently on our schedule
for the 2.1 release of Doctrine only.</p>
<p>Until then I wrote a very little extension for Doctrine2 that
allows you to work with large collections. It has two methods that
compute the following data for any given <code>PersistentCollection</code>:</p>
<ul><li class="dash"> Total Number of Elements in the Collection</li>
<li class="dash"> A slice of entities from the collection using a sql limit (or
   alternative)</li>
</ul>

<p>You can get this extension from the
<a href="http://github.com/beberlei/DoctrineExtensions">DoctrineExtensions Github repository</a>.</p>
<a id="title.1"></a><h1>Working with a LargeCollection</h1>
<p>The <code>LargeCollection</code> class is a handler to work with large
PersistentCollections. You can instantiate it by passing an
<code>EntityManager</code> instance:</p>
<pre><code class="php">&lt;?php
use DoctrineExtensions\LargeCollections\LargeCollection;

$lc = new LargeCollection($em);

**NOTE**

LargeCollection only works with instances of
``PersistentCollection``, not with other implementations of the
``Doctrine\Common\Collections\Collection`` interface. That means
that you can only pass collections to it, whose owning entities
have been persisted before or are retrieved from the
EntityManager.

</code></pre>
<p>You can compute the total number of elements in a given collection
by passing it to the count method:</p>
<pre><code class="php">&lt;?php
$size = $lc-&gt;count($article-&gt;getComments());
</code></pre>
<p>You can retrieve a slice of entities from the collection by
calling:</p>
<pre><code class="php">&lt;?php
$slice = $lc-&gt;getSliceQuery($article-&gt;getComments(), $limit = 30);
</code></pre>
<p>As you can see this is very simple to use, but also missing some
bits:</p>
<ul><li class="dash"> In your domain models you sometimes don't want to return the
   <code>Collections</code> instance but call <code>toArray()</code> to encapsulate the
   Collections API inside the Entity. For this two new methods are
   required to access to the persistent collections from the inside of
   an entity.</li>
<li class="dash"> The <code>remove</code>, <code>removeElement</code>, <code>contains</code> and
   <code>containsKey</code> methods could also be added to the large collection
   handler, making direct calls to the underlying UnitOfWork API.</li>
<li class="dash"> A method that returns an <code>IterableResult</code> for any given
   collection. This would allow to iterate the complete collection on
   a row-by-row basis, which would eliminate possible max memory
   problems compared to the complete hydration of a collection.</li>
<li class="dash"> Methods link()/unlink() like described in
   <a href="http://www.doctrine-project.org/jira/browse/DDC-128">DDC-128</a></li>
</ul>

<p>I hope I got your attention and maybe someone has an interest in
extending the LargeCollection a little bit more.</p>

        </div>

            </article>
    <article>
        <header>
            <h2><a href="https://staging.doctrine-project.org/2010/07/07/implementing-aggregate-fields.html">Implementing Aggregate Fields with Doctrine 2</a></h2>
        </header>

        <p class="lead">
            Posted on 2010-07-07
                            by
                                    beberlei
                                    </p>

        <hr />

        <div>
            <p>You will often come across the requirement to display aggregate
values of data that can be computed by using the MIN, MAX, COUNT or
SUM SQL functions. For any ORM this is a tricky issue
traditionally. Doctrine 2 offers several ways to get access to
these values and this article will describe all of them from
different perspectives.</p>
<p>You will see that aggregate fields can become very explicit
features in your domain model and how this potentially complex
business rules can be easily tested.</p>
<a id="title.1"></a><h1>An example model</h1>
<p>Say you want to model a bank account and all their entries. Entries
into the account can either be of positive or negative money
values. Each account has a credit limit and the account is never
allowed to have a balance below that value.</p>
<p>For simplicity we live in a world were money is composed of
integers only. Also we omit the receiver/sender name, stated reason
for transfer and the execution date. These all would have to be
added on the <code>Entry</code> object.</p>
<p>Our entities look like:</p>
<pre><code class="php">&lt;?php
namespace Bank\Entities;

/**
 * @Entity
 */
class Account
{
    /** @Id @GeneratedValue @Column(type=&quot;integer&quot;) */
    private $id;

    /** @Column(type=&quot;string&quot;, unique=true) */
    private $no;

    /**
     * @OneToMany(targetEntity=&quot;Entry&quot;, mappedBy=&quot;entries&quot;, cascade={&quot;persist&quot;})
     */
    private $entries;

    /**
     * @Column(type=&quot;integer&quot;)
     */
    private $maxCredit = 0;

    public function __construct($no, $maxCredit = 0)
    {
        $this-&gt;no = $no;
        $this-&gt;maxCredit = $maxCredit;
        $this-&gt;entries = new \Doctrine\Common\Collections\ArrayCollection();
    }
}

/**
 * @Entity
 */
class Entry
{
    /** @Id @GeneratedValue @Column(type=&quot;integer&quot;) */
    private $id;

    /**
     * @ManyToOne(targetEntity=&quot;Account&quot;, inversedBy=&quot;entries&quot;)
     */
    private $account;

    /**
     * @Column(type=&quot;integer&quot;)
     */
    private $amount;

    public function __construct($account, $amount)
    {
        $this-&gt;account = $account;
        $this-&gt;amount = $amount;
        // more stuff here, from/to whom, stated reason, execution date and such
    }

    public function getAmount()
    {
        return $this-&gt;amount;
    }
}
</code></pre>
<a id="title.2"></a><h1>Using DQL</h1>
<p>The Doctrine Query Language allows you to select for aggregate
values computed from fields of your Domain Model. You can select
the current balance of your account by calling:</p>
<pre><code class="php">&lt;?php
$dql = &quot;SELECT SUM(e.amount) AS balance FROM Bank\Entities\Entry e &quot; .
       &quot;WHERE e.account = ?1&quot;;
$balance = $em-&gt;createQuery($dql)
              -&gt;setParameter(1, $myAccountId)
              -&gt;getSingleScalarResult();
</code></pre>
<p>The <code>$em</code> variable in this (and forthcoming) example holds the
Doctrine <code>EntityManager</code>. We create a query for the SUM of all
amounts (negative amounts are withdraws) and retrieve them as a
single scalar result, essentially return only the first column of
the first row.</p>
<p>This approach is simple and powerful, however it has a serious
drawback. We have to execute a specific query for the balance
whenever we need it.</p>
<p>To implement a powerful domain model we would rather have access to
the balance from our <code>Account</code> entity during all times (even if
the Account was not persisted in the database before!).</p>
<p>Also an additional requirement is the max credit per <code>Account</code>
rule.</p>
<p>We cannot reliably enforce this rule in our <code>Account</code> entity with
the DQL retrieval of the balance. There are many different ways to
retrieve accounts. We cannot guarantee that we can execute the
aggregation query for all these use-cases, let alone that a
userland programmer checks this balance against newly added
entries.</p>
<a id="title.3"></a><h1>Using your Domain Model</h1>
<p><code>Account</code> and all the <code>Entry</code> instances are connected through a
collection, which means we can compute this value at runtime:</p>
<pre><code class="php">&lt;?php
class Account
{
    // .. previous code
    public function getBalance()
    {
        $balance = 0;
        foreach ($this-&gt;entries AS $entry) {
            $balance += $entry-&gt;getAmount();
        }
        return $balance;
    }
}
</code></pre>
<p>Now we can always call <code>Account::getBalance()</code> to access the
current account balance.</p>
<p>To enforce the max credit rule we have to implement the &quot;Aggregate
Root&quot; pattern as described in Eric Evans book on Domain Driven
Design. Described with one sentence, an aggregate root controls the
instance creation, access and manipulation of its children.</p>
<p>In our case we want to enforce that new entries can only added to
the <code>Account</code> by using a designated method. The <code>Account</code> is
the aggregate root of this relation. We can also enforce the
correctness of the bi-directional <code>Account</code> &lt;-&gt; <code>Entry</code>
relation with this method:</p>
<pre><code class="php">&lt;?php
class Account
{
    public function addEntry($amount)
    {
        $this-&gt;assertAcceptEntryAllowed($amount);

        $e = new Entry($this, $amount);
        $this-&gt;entries[] = $e;
        return $e;
    }
}
</code></pre>
<p>Now look at the following test-code for our entities:</p>
<pre><code class="php">&lt;?php
class AccountTest extends \PHPUnit_Framework_TestCase
{
    public function testAddEntry()
    {
        $account = new Account(&quot;123456&quot;, $maxCredit = 200);
        $this-&gt;assertEquals(0, $account-&gt;getBalance());

        $account-&gt;addEntry(500);
        $this-&gt;assertEquals(500, $account-&gt;getBalance());

        $account-&gt;addEntry(-700);
        $this-&gt;assertEquals(-200, $account-&gt;getBalance());
    }

    public function testExceedMaxLimit()
    {
        $account = new Account(&quot;123456&quot;, $maxCredit = 200);

        $this-&gt;setExpectedException(&quot;Exception&quot;);
        $account-&gt;addEntry(-1000);
    }
}
</code></pre>
<p>To enforce our rule we can now implement the assertion in
<code>Account::addEntry</code>:</p>
<pre><code class="php">&lt;?php
class Account
{
    private function assertAcceptEntryAllowed($amount)
    {
        $futureBalance = $this-&gt;getBalance() + $amount;
        $allowedMinimalBalance = ($this-&gt;maxCredit * -1);
        if ($futureBalance &lt; $allowedMinimalBalance) {
            throw new Exception(&quot;Credit Limit exceeded, entry is not allowed!&quot;);
        }
    }
}
</code></pre>
<p>We haven't talked to the entity manager for persistence of our
account example before. You can call
<code>EntityManager::persist($account)</code> and then
<code>EntityManager::flush()</code> at any point to save the account to the
database. All the nested <code>Entry</code> objects are automatically
flushed to the database also.</p>
<pre><code class="php">&lt;?php
$account = new Account(&quot;123456&quot;, 200);
$account-&gt;addEntry(500);
$account-&gt;addEntry(-200);
$em-&gt;persist($account);
$em-&gt;flush();
</code></pre>
<p>The current implementation has a considerable drawback. To get the
balance, we have to initialize the complete <code>Account::$entries</code>
collection, possibly a very large one. This can considerably hurt
the performance of your application.</p>
<a id="title.4"></a><h1>Using an Aggregate Field</h1>
<p>To overcome the previously mentioned issue (initializing the whole
entries collection) we want to add an aggregate field called
&quot;balance&quot; on the Account and adjust the code in
<code>Account::getBalance()</code> and <code>Account:addEntry()</code>:</p>
<pre><code class="php">&lt;?php
class Account
{
    /**
     * @Column(type=&quot;integer&quot;)
     */
    private $balance = 0;

    public function getBalance()
    {
        return $this-&gt;balance;
    }

    public function addEntry($amount)
    {
        $this-&gt;assertAcceptEntryAllowed($amount);

        $e = new Entry($this, $amount);
        $this-&gt;entries[] = $e;
        $this-&gt;balance += $amount;
        return $e;
    }
}
</code></pre>
<p>This is a very simple change, but all the tests still pass. Our
account entities return the correct balance. Now calling the
<code>Account::getBalance()</code> method will not occour the overhead of
loading all entries anymore. Adding a new Entry to the
<code>Account::$entities</code> will also not initialize the collection
internally.</p>
<p>Adding a new entry is therefore very performant and explictly
hooked into the domain model. It will only update the account with
the current balance and insert the new entry into the database.</p>
<a id="title.5"></a><h1>Tackling Race Conditions with Aggregate Fields</h1>
<p>Whenever you denormalize your database schema race-conditions can
potentially lead to inconsistent state. See this example:</p>
<pre><code class="php">&lt;?php
// The Account $accId has a balance of 0 and a max credit limit of 200:
// request 1 account
$account1 = $em-&gt;find('Bank\Entities\Account', $accId);

// request 2 account
$account2 = $em-&gt;find('Bank\Entities\Account', $accId);

$account1-&gt;addEntry(-200);
$account2-&gt;addEntry(-200);

// now request 1 and 2 both flush the changes.
</code></pre>
<p>The aggregate field <code>Account::$balance</code> is now -200, however the
SUM over all entries amounts yields -400. A violation of our max
credit rule.</p>
<p>You can use both optimistic or pessimistic locking to save-guard
your aggregate fields against this kind of race-conditions. Reading
Eric Evans DDD carefully he mentions that the &quot;Aggregate Root&quot;
(Account in our example) needs a locking mechanism.</p>
<p>Optimistic locking is as easy as adding a version column:</p>
<pre><code class="php">&lt;?php
class Amount
{
    /** @Column(type=&quot;integer&quot;) @Version */
    private $version;
}
</code></pre>
<p>The previous example would then throw an exception in the face of
whatever request saves the entity last (and would create the
inconsistent state).</p>
<p>Pessimmistic locking requires an additional flag set on the
<code>EntityManager::find()</code> call, enabling write locking directly in
the database using a FOR UPDATE.</p>
<pre><code class="php">&lt;?php
use Doctrine\DBAL\LockMode;

$account = $em-&gt;find('Bank\Entities\Account', $accId, LockMode::PESSIMISTIC_READ); 
</code></pre>
<a id="title.6"></a><h1>Keeping Updates and Deletes in Sync</h1>
<p>The example shown in this article does not allow changes to the
value in <code>Entry</code>, which considerably simplifies the effort to
keep <code>Account::$balance</code> in sync. If your use-case allows fields
to be updated or related entities to be removed you have to
encapsulate this logic in your &quot;Aggregate Root&quot; entity and adjust
the aggregate field accordingly.</p>
<a id="title.7"></a><h1>Conclusion</h1>
<p>This article described how to obtain aggregate values using DQL or
your domain model. It showed how you can easily add an aggregate
field that offers serious performance benefits over iterating all
the related objects that make up an aggregate value. Finally I
showed how you can ensure that your aggregate fields do not get out
of sync due to race-conditions and concurrent access.</p>

        </div>

            </article>

    <nav class="mt-4">
        <ul class="pagination">
            <li class="page-item"><a class="page-link" href="https://staging.doctrine-project.org/blog/page/45.html">Newer Posts</a></li><br />
            <li class="page-item"><a class="page-link" href="https://staging.doctrine-project.org/blog/page/47.html">Older Posts</a></li>        </ul>
    </nav>
            </main>

        
        <button id="back-to-top" title="Go to top">Top</button>

        <script
          src="https://code.jquery.com/jquery-3.3.1.min.js"
          integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
          crossorigin="anonymous"></script>

        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>

        <script
            src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>

        <script src="https://staging.doctrine-project.org/components/highlightjs/highlight.pack.js?3970aa"></script>

        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0"></script>

        <script id="instantsearch-template" type="text/template">
            
    <a href="{{url}}" class="list-group-item list-group-item-action flex-column align-items-start">
        <div class="d-flex w-100 justify-content-between">
            <h5 class="mb-1">{{{_highlightResult.projectName.value}}}: {{{_highlightResult.h1.value}}}</h5>
        </div>

        {{#h2}}
            <p class="mb-1">
                <i class="far fa-arrow-alt-circle-right text-primary"></i>

                {{{_highlightResult.h2.value}}}

                {{#h3}}
                    > {{{_highlightResult.h3.value}}}
                {{/h3}}

                {{#h4}}
                    > {{{_highlightResult.h4.value}}}
                {{/h4}}

                {{#h5}}
                    > {{{_highlightResult.h5.value}}}
                {{/h5}}
            </p>
        {{/h2}}

        {{#content}}
            <div class="content p-2 rounded" style="background-color: rgba(0,0,0,.125);">
                {{{_highlightResult.content.value}}}
            </div>
        {{/content}}
    </a>

        </script>

        <script src="https://staging.doctrine-project.org/js/main.js?f32c09"></script>
        <script src="https://staging.doctrine-project.org/js/search.js?36322d"></script>

        <script type="text/javascript">
            var projectSlug = '';
            var versionSlug = 'latest';

            new Main();

            new Search(projectSlug, versionSlug);
        </script>

        
        
        
            </body>
</html>
