<!DOCTYPE html>
<html>
    <head>
        <title>Working with Objects - Doctrine - PHP Database Tools</title>

        <meta charset="utf-8">
        <meta name="theme-color" content="#ffffff">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

                    <meta name="robots" content="noindex, follow">
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.8/css/all.css" integrity="sha384-3AB7yXWz4OeoZcPbieVW64vVXEwADiYyAEhwilzWsLw+9FgqpyjjStpPnpBO8o8S" crossorigin="anonymous">

        <link href="https://new.doctrine-project.org/css/style.css?9" rel="stylesheet" type="text/css" />

        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">

        <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://new.doctrine-project.org/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://new.doctrine-project.org/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://new.doctrine-project.org/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://new.doctrine-project.org/images/apple-touch-icon-144x144.png" />
        <link rel="apple-touch-icon-precomposed" sizes="60x60" href="https://new.doctrine-project.org/images/apple-touch-icon-60x60.png" />
        <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://new.doctrine-project.org/images/apple-touch-icon-120x120.png" />
        <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://new.doctrine-project.org/images/apple-touch-icon-76x76.png" />
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://new.doctrine-project.org/images/apple-touch-icon-152x152.png" />
        <link rel="icon" type="image/png" href="https://new.doctrine-project.org/images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="https://new.doctrine-project.org/images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="https://new.doctrine-project.org/images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="https://new.doctrine-project.org/images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="https://new.doctrine-project.org/images/favicon-128.png" sizes="128x128" />
        <meta name="application-name" content="Doctrine"/>
        <meta name="msapplication-TileColor" content="#FFFFFF" />
        <meta name="msapplication-TileImage" content="https://new.doctrine-project.org/images/mstile-144x144.png" />
        <meta name="msapplication-square70x70logo" content="https://new.doctrine-project.org/images/mstile-70x70.png" />
        <meta name="msapplication-square150x150logo" content="https://new.doctrine-project.org/images/mstile-150x150.png" />
        <meta name="msapplication-wide310x150logo" content="https://new.doctrine-project.org/images/mstile-310x150.png" />
        <meta name="msapplication-square310x310logo" content="https://new.doctrine-project.org/images/mstile-310x310.png" />

        <link rel="stylesheet" href="https://new.doctrine-project.org/components/highlightjs/styles/railscasts.css?9" />
        <link rel="alternate" type="application/atom+xml" href="https://new.doctrine-project.org/atom.xml" title="Doctrine activity feed" />

        
        
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0/dist/instantsearch.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0/dist/instantsearch-theme-algolia.min.css">
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0"></script>
    </head>
    <body>

        <header>
            <nav class="navbar navbar-expand-md navbar-dark border-bottom">
                <a class="navbar-brand text-hide" href="https://new.doctrine-project.org/"><img src="https://new.doctrine-project.org/images/doctrine-logo.svg" />Doctrine</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarCollapse">
                    <ul class="navbar-nav mr-auto">
                        <li class="nav-item active">
                            <a class="nav-link" href="https://new.doctrine-project.org/">Home</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://new.doctrine-project.org/about/">About</a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="https://new.doctrine-project.org/projects/" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                Projects
                            </a>
                            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/orm/">ORM</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/dbal/">DBAL</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/mongodb-odm/">MongoDB ODM</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/phpcr-odm/">PHPCR ODM</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/couchdb-odm/">CouchDB ODM</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/migrations/">Migrations</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/common/">Common</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/mongodb/">MongoDB</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/orientdb-odm/">OrientDB ODM</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/annotations/">Annotations</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/collections/">Collections</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/inflector/">Inflector</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/cache/">Cache</a>
                                                                    <a class="dropdown-item" href="https://new.doctrine-project.org/projects/lexer/">Lexer</a>
                                                            </div>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://new.doctrine-project.org/contribute/">Contribute</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://new.doctrine-project.org/community/">Community</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://new.doctrine-project.org/blog/">Blog</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://new.doctrine-project.org/search/">Search</a>
                        </li>
                        <li class="nav-item active">
                            <a class="nav-link" href="https://github.com/doctrine/" target="_blank">Development</a>
                        </li>
                    </ul>
                </div>
            </nav>
        </header>

        <!-- Begin page content -->
        <main role="main" class="container">
                                                                
                                
                                                    <nav aria-label="breadcrumb">
                        <ol class="breadcrumb">
                            <li class="breadcrumb-item"><a href="https://new.doctrine-project.org/">Home</a></li>
                            <li class="breadcrumb-item"><a href="https://new.doctrine-project.org/projects/">Projects</a></li>
                            <li class="breadcrumb-item"><a href="https://new.doctrine-project.org/projects/phpcr-odm/">PHPCR ODM</a></li>
                            <li class="breadcrumb-item"><a href="https://new.doctrine-project.org/projects/doctrine-phpcr-odm/en/latest/">Documentation</a></li>
                            <li class="breadcrumb-item active" aria-current="page">Working with Objects</li>
                        </ol>
                    </nav>
                
                                    <ul class="list-inline float-right">
                                                    <li class="list-inline-item mr-0">
                                <a href="/projects/doctrine-phpcr-odm/en/latest/reference/working-with-objects.html" class="badge badge-primary">master</a>
                            </li>
                                            </ul>
                
                <!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
</head>
<body>
<h1 class="section-header" id="title.1"><a href="#title.1">Working with Objects<i class="fas fa-link"></i></a></h1>
<p>This chapter explains how to work with the <code>DocumentManager</code> and the
<code>UnitOfWork</code>. The Unit of Work encapsulates the information to be written
to PHPCR when you call <code>DocumentManager#flush()</code>.</p>
<p>A Unit of Work can be manually closed by calling <code>DocumentManager#close()</code>.
Any changes to documents within this UnitOfWork that have not yet been
persisted are lost.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>It is very important to understand that only
<code>DocumentManager::flush()</code> ever causes write operations against the
repository to be executed. Any other methods such as
<code>DocumentManager::persist($document)</code> or
<code>DocumentManager::remove($document)</code> only notify the UnitOfWork to
perform these operations during flush.</p>
<p>Not calling <code>DocumentManager::flush()</code> will lead to all changes
during that request being lost.</p>
</div>
<div class="alert tip bg-success text-light"><i class="fas fa-question-circle mr-2"></i><p>The <code>DocumentManager</code> is very similar to the Doctrine ORM EntityManager and
this chapter is similar to its <a href="https://doctrine-orm.readthedocs.org/en/latest/reference/working-with-objects.html">corresponding ORM chapter</a>.
This chapter tries to help you by highlighting the places where PHPCR-ODM
is different from the ORM.</p>
</div>
<h2 class="section-header" id="title.1.1"><a href="#title.1.1">Documents and the Identity Map<i class="fas fa-link"></i></a></h2>
<p>Objects managed by Doctrine PHPCR-ODM are called <em>documents</em>.
Every document has an identifier, which is its PHPCR path. The path is unique
inside the workspace. Take the following example, where you find an article
with the headline &quot;Hello World&quot; with the ID <code>/cms/article/hello-world</code>:</p>
<pre><code class="">$article = $documentManager-&gt;find(null, '/cms/article/hello-world');
$article-&gt;setHeadline('Hello World dude!');

$article2 = $documentManager-&gt;find(null, '/cms/article/hello-world');
echo $article2-&gt;getHeadline(); // Hello World dude!
</code></pre>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>The first argument to <code>find()</code> is the document class name. While the ORM
has a table per class and thus always needs the document class name,
PHPCR-ODM has one tree for all documents. The above call will find you
whatever document is at that path. Note that you may optionally specify
the class name to have PHPCR-ODM detect if the document is not of the
expected type.</p>
</div>
<p>In this case, the article is retrieved from the document manager twice,
but modified in between. Doctrine 2 realizes that it is the same ID and will
only ever give you access to one instance of the Article with ID
<code>/cms/article/hello-world</code>, no matter how often do you retrieve it from
the <code>DocumentManager</code> and even no matter what kind of Query method you are
using (find, findBy, query builder, getDocumentsByPhpcrQuery). This is
called &quot;Identity Map&quot; pattern, which means Doctrine keeps a map of each
document that has been retrieved in the current PHP request and keeps
returning you the same instances.</p>
<p>In the previous example the <code>echo</code> prints &quot;Hello World dude!&quot; to the
screen. You can even verify that <code>$article</code> and <code>$article2</code> are
indeed pointing to the same instance by running the following
code:</p>
<pre><code class="">if ($article === $article2) {
    echo &quot;Yes we are the same!&quot;;
}
</code></pre>
<p>Sometimes you want to clear the identity map of a <code>DocumentManager</code> to
start over. We use this regularly in our unit tests to enforce
loading documents from the repository again instead of serving them
from the identity map. You can call <code>DocumentManager::clear()</code> to
achieve this result.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>In PHPCR-ODM, the ID is the PHPCR path of the document. This means it is
possible to change the ID of a document by moving it in the tree using the
the <code>DocumentManager::move()</code> operation.
To create a reference to a document that is stable over move operations,
make the document <em>referenceable</em> and map the <code>Uuid</code> field. You can find
a document by its universally unique identifier.</p>
</div>
<h2 class="section-header" id="title.1.2"><a href="#title.1.2">Document Graph Traversal<i class="fas fa-link"></i></a></h2>
<p>Although Doctrine allows for a complete separation of your domain
model (Document classes) there will never be a situation where
documents are &quot;missing&quot; when traversing associations. You can walk
all the associations inside your document models as deep as you
want.</p>
<p>Take the following example of a single <code>Article</code> document fetched
from newly opened DocumentManager:</p>
<pre><code class="">use Doctrine\ODM\PHPCR\Mapping\Annotations as PHPCR;

/**
 * @PHPCR\Document
 */
class Article
{
    /**
     * @PHPCR\Id
     */
    private $id;

    /**
     * @PHPCR\Field(type=&quot;string&quot;)
     */
    private $headline;

    /**
     * @PHPCR\ReferenceOne
     */
    private $author;

    /**
     * @PHPCR\Referrers(referrerDocument=&quot;Comment&quot;, referencedBy=&quot;article&quot;)
     */
    private $comments;

    public function __construct {
        $this-&gt;comments = new ArrayCollection();
    }

    public function getAuthor() { return $this-&gt;author; }
    public function getComments() { return $this-&gt;comments; }
}

$article = $em-&gt;find(null, '/cms/article/hello-world');
</code></pre>
<p>This code retrieves an <code>Article</code> instance with ID
<code>/cms/article/hello-world</code>, executing a single <code>getNode()</code> operation
on the repository, retrieving only the data required for the specified
article. However, you can still access the associated properties author
and comments and the associated documents they contain.</p>
<p>This works by utilizing the lazy loading pattern. Instead of
passing you back a real Author instance and a collection of
comments, Doctrine will create proxy instances for you. Only if you
access these proxies for the first time they will go through the
<code>DocumentManager</code> and load their state from the repository.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>In PHPCR-ODM, relations between documents are expressed in <em>references</em>.
References are directed links. You can map the backlinks using the
<code>Referrers</code> mapping.</p>
</div>
<p>This lazy-loading process happens behind the scenes, hidden from
your code. Have a look at the following example:</p>
<pre><code class="">$article = $em-&gt;find(null, '/cms/article/hello-world');

// accessing a method of the user instance triggers the lazy-load
echo &quot;Author: &quot; . $article-&gt;getAuthor()-&gt;getName() . &quot;\n&quot;;

if ($article-&gt;getAuthor() instanceof User) {
    // getAuthor returns a proxy class which is instanceof User
}

// accessing the comments as an iterator triggers the lazy-load
// retrieving ALL the comments of this article from the repository
// using a single getNodes call
foreach ($article-&gt;getComments() AS $comment) {
    echo $comment-&gt;getText() . &quot;\n\n&quot;;
}

// Article::$comments passes instanceof tests for the Collection interface
// But it will NOT pass for the ArrayCollection interface
if ($article-&gt;getComments() instanceof \Doctrine\Common\Collections\Collection) {
    echo &quot;This will always be true!&quot;;
}
</code></pre>
<p>A slice of the generated proxy classes code looks like the
following example. Real proxy class override <em>all</em> public
methods along the lines of the <code>getName()</code> method shown below:</p>
<pre><code class="">class UserProxy extends User implements Proxy
{
    private function _load()
    {
        // lazy loading code
    }

    public function getName()
    {
        $this-&gt;_load();
        return parent::getName();
    }
    // .. other public methods of User
}
</code></pre>
<div class="alert warning bg-light-yellow text-dark border"><i class="fas fa-exclamation-circle text-warning mr-2"></i><p>Traversing the object graph for parts that are lazy-loaded will
easily trigger lots of repository lookups and will perform badly if used
too heavily. If you often use child documents for example, look into
the <code>fetchDepth</code> configuration.</p>
</div>
<h2 class="section-header" id="title.1.3"><a href="#title.1.3">Persisting documents<i class="fas fa-link"></i></a></h2>
<p>When you create a new document, the <code>DocumentManager</code> knows nothing about it.
You need to call <code>DocumentManager::persist($document)</code> to make the document
MANAGED. You only need to do that on object instantiation. From now on,
whenever you modify the object you loaded from the <code>DocumentManager</code>, it will
automatically be synchronized with the repository when
<code>DocumentManager::flush()</code> is invoked.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>Invoking the <code>persist</code> method for a document does NOT
cause an immediate addNode on the repository.
Doctrine applies a strategy called &quot;transactional write-behind&quot;,
which means that it will delay most SQL commands until
<code>DocumentManager::flush()</code> is invoked which will then issue all
necessary PHPCR calls to synchronize your documents with the
repository in the most efficient way - a single, short transaction -
taking care of maintaining referential integrity.</p>
</div>
<p>Example:</p>
<pre><code class="">$user = new User;
$user-&gt;setName('Mr.Right');
$dm-&gt;persist($user);
$dm-&gt;flush();
</code></pre>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>Generated document identifiers / primary keys are
guaranteed to be available after the next successful flush
operation that involves the document in question. You may not rely on
a generated identifier to be available directly after invoking
<code>persist</code>. The inverse is also true. After a failed flush,
a document may already show a generated identifier even though
it was not persisted.</p>
</div>
<p>The semantics of the persist operation, applied on a document X, are
as follows:</p>
<ul><li> If X is a new document, it becomes managed. The document X will be
   entered into the repository as a result of the flush operation;</li>
<li> If X is a pre-existing managed document, it is ignored by the
   persist operation. However, the persist operation is cascaded to
   documents referenced by X if the relationships from X to these
   other documents are mapped with <code>cascade=PERSIST</code> or <code>cascade=ALL</code> (see
   &quot;Transitive Persistence&quot;);</li>
<li> If X is a removed document, it becomes managed;</li>
<li> If X is a detached document, an exception will be thrown on
   flush.</li>
</ul>

<h2 class="section-header" id="title.1.4"><a href="#title.1.4">Removing documents<i class="fas fa-link"></i></a></h2>
<p>A document can be removed from persistent storage by passing it to
the <code>DocumentManager::remove($document)</code> method. By applying the
<code>remove</code> operation on some document, that document becomes REMOVED,
which means that its persistent state will be deleted once
<code>DocumentManager::flush()</code> is invoked.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>Just like <code>persist</code>, invoking <code>remove</code> with a document
does NOT cause an immediate remove() to be issued on the
repository. The document will be deleted on the next invocation of
<code>DocumentManager::flush()</code> that involves that document. This
means that documents scheduled for removal can still be queried
for and appear in query and collection results. See
the section on <a href="workingobjects_repository_uow_outofsync.html">Repository and UnitOfWork Out-Of-Sync</a>
for more information.</p>
</div>
<p>Example:</p>
<pre><code class="">$dm-&gt;remove($user);
$dm-&gt;flush();
</code></pre>
<p>The semantics of the remove operation, applied to a document X are
as follows:</p>
<ul><li> If X is a new document, it is ignored by the remove operation.
   However, the remove operation is cascaded to documents referenced by
   X, if the relationship from X to these other documents is mapped
   with <code>cascade=REMOVE</code> or <code>cascade=ALL</code> (see &quot;Transitive Persistence&quot;);</li>
<li> If X is a managed document, the remove operation causes it to
   become removed. The remove operation is cascaded to documents
   referenced by X, if the relationships from X to these other
   documents is mapped with <code>cascade=REMOVE</code> or <code>cascade=ALL</code> (see
   &quot;Transitive Persistence&quot;);</li>
<li> If X is a detached document, an <code>InvalidArgumentException</code> will be
   thrown;</li>
<li> If X is a removed document, it is ignored by the remove operation;</li>
<li> A removed document X will be removed from the repository as a result
   of the flush operation.</li>
</ul>

<p>After a document has been removed, its in-memory state is the same as
before the removal, except that the identifier is set to null.</p>
<p>Removing a document will also <strong>automatically delete any children</strong> of it.
Note that no events will be triggered for the removed children, only for
the document explicitly removed.</p>
<p>By default, references and referring documents are not deleted. You can enable
this by configuring cascading removal on the association mapping. If an association
is marked as <code>CASCADE=REMOVE</code>, PHPCR-ODM will follow this association. If
its a Single association it will pass this document to
<code>DocumentManager::remove()</code>. If the association is a collection, Doctrine
will loop over all its elements and pass them to<code>DocumentManager::remove()</code>.
In both cases the cascade remove semantics are applied recursively.
For large object graphs this removal strategy can be very costly.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>Contrary to the ORM, the PHPCR query language knows no DELETE statement.
If you expect to remove large object graphs, try to model them in a way
that you can simply remove the parent, as children removal is as cheap
as having a relational database cascade removal through foreign keys.</p>
</div>
<h2 class="section-header" id="title.1.5"><a href="#title.1.5">Detaching documents<i class="fas fa-link"></i></a></h2>
<p>You can make Doctrine stop tracking a document by detaching it from
the <code>UnitOfWork</code>. To do this, you invoke the
<code>DocumentManager::detach($document)</code> method with the document. Changes
made to the detached document, including removal of the document, will
not be synchronized to the repository after the document has been
detached.</p>
<p>Doctrine will discard all references to a detached document.</p>
<p>Example:</p>
<pre><code class="">$dm-&gt;detach($document);
</code></pre>
<p>The semantics of the detach operation, applied to a document X are
as follows:</p>
<ul><li> If X is a managed document, the detach operation causes it to
   become detached. The detach operation is cascaded to documents
   referenced by X, if the relationships from X to these other
   documents is mapped with <code>cascade=DETACH</code> or <code>cascade=ALL</code> (see
   &quot;Transitive Persistence&quot;). Documents which previously referenced X
   will continue to reference X;</li>
<li> If X is a new or detached document, it is ignored by the detach
   operation;</li>
<li> If X is a removed document, the detach operation is cascaded to
   documents referenced by X, if the relationships from X to these
   other documents is mapped with <code>cascade=DETACH</code> or <code>cascade=ALL</code> (see
   &quot;Transitive Persistence&quot;). Documents which previously referenced X
   will continue to reference X.</li>
</ul>

<p>There are several situations in which a document will become detached
automatically without invoking the <code>detach</code> method:</p>
<ul><li> When <code>DocumentManager::clear()</code> is invoked, all documents that are
   currently managed by the <code>DocumentManager</code> instance become detached;</li>
<li> When serializing a document. The document retrieved upon subsequent
   unserialization will be detached (This is the case for all documents
   that are serialized and stored in some cache).</li>
</ul>

<p>The <code>detach</code> operation is usually not as frequently needed and
used as <code>persist</code> and <code>remove</code>.</p>
<h2 class="section-header" id="title.1.6"><a href="#title.1.6">Merging documents<i class="fas fa-link"></i></a></h2>
<p>Merging documents refers to the merging of (usually detached)
documents into the context of a <code>DocumentManager</code> so that they become
managed again. To merge the state of a document into a
<code>DocumentManager</code> use the <code>DocumentManager::merge($document)</code> method. The
state of the passed document will be merged into a managed copy of
this document and this copy will subsequently be returned.</p>
<p>Example:</p>
<pre><code class="">$detachedDocument = unserialize($serializedDocument); // some detached document
$document = $em-&gt;merge($detachedDocument);
// $document now refers to the fully managed copy returned by the merge operation.
// The DocumentManager now manages the persistence of $document as usual.

</code></pre>
<p>The semantics of the merge operation, applied to a document X, are
as follows:</p>
<ul><li> If X is a detached document, the state of X is copied onto a
   pre-existing managed document instance X' of the same identity;</li>
<li> If X is a new document instance, a new managed copy X' will be
   created and the state of X is copied onto this managed instance;</li>
<li> If X is a removed document instance, an <code>InvalidArgumentException</code>
   will be thrown;</li>
<li> If X is a managed document, it is ignored by the merge operation,
   however, the merge operation is cascaded to documents referenced by
   relationships from X if these relationships have been mapped with
   the cascade element value MERGE or ALL (see &quot;Transitive
   Persistence&quot;);</li>
<li> For all documents Y referenced by relationships from X having the
   cascade element value <code>MERGE</code> or <code>ALL</code>, Y is merged recursively as Y'.
   For all such Y referenced by X, X' is set to reference Y'. (Note
   that if X is managed then X is the same object as X'.);</li>
<li> If X is a document merged to X', with a reference to another
   document Y, where <code>cascade=MERGE</code> or <code>cascade=ALL</code> is not specified, then
   navigation of the same association from X' yields a reference to a
   managed object Y' with the same persistent identity as Y.</li>
</ul>

<p>The <code>merge</code> operation is usually not as frequently needed and
used as <code>persist</code> and <code>remove</code>. The most common scenario for
the <code>merge</code> operation is to reattach documents to a <code>DocumentManager</code>
that come from some cache (and are therefore detached) and you want
to modify and persist such a document.</p>
<div class="alert warning bg-light-yellow text-dark border"><i class="fas fa-exclamation-circle text-warning mr-2"></i><p>If you need to perform multiple merges of documents that share
certain subparts of their object-graphs and cascade merge, then you
have to call <code>DocumentManager::clear()</code> between the successive
calls to <code>DocumentManager::merge()</code>. Otherwise you might end up
with multiple copies of the &quot;same&quot; object in the repository, however
with different IDs, or a duplicate ID conflict - depending on how
you generate IDs.</p>
</div>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>If you load some detached documents from a cache and you do
not need to persist or delete them or otherwise make use of them
without the need for persistence services there is no need to use
<code>merge</code>. I.e. you can simply pass detached objects from a cache
directly to the view.</p>
</div>
<h2 class="section-header" id="title.1.7"><a href="#title.1.7">Synchronization with the Repository<i class="fas fa-link"></i></a></h2>
<p>The state of persistent documents is synchronized with the repository
by calling <code>flush</code> on a <code>DocumentManager</code> by commiting the underlying
<code>UnitOfWork</code>. The synchronization involves writing any updates to
persistent documents and their relationships to the repository.
Thereby bidirectional relationships are persisted based on the
references held by the owning side of the relationship as explained
in the Association Mapping chapter.</p>
<p>When <code>DocumentManager::flush()</code> is called, Doctrine inspects all
managed, new and removed documents and will perform the necessary
operations.</p>
<a id="workingobjects_repository_uow_outofsync"></a>
<h3 class="section-header" id="title.1.7.1"><a href="#title.1.7.1">Effects of Repository and UnitOfWork being Out-Of-Sync<i class="fas fa-link"></i></a></h3>
<p>As soon as you begin to change the state of documents, call persist or remove the
contents of the UnitOfWork and the repository will get out of sync. They can
only be synchronized by calling <code>DocumentManager::flush()</code>. This section
describes the effects of repository and UnitOfWork being out of sync.</p>
<ul><li> Documents that are scheduled for removal can still be queried from the repository.
   They are returned from queries, calls to getReferrers and getChildren and
   stay visible in collections;</li>
<li> Documents that are passed to <code>DocumentManager::persist</code> do not turn up in query
   results and do not appear in collections;</li>
<li> Documents that have changed will not be overwritten with the state from the repository.
   This is because the identity map will detect the construction of an already existing
   document and assumes its the most up to date version.</li>
</ul>

<p><code>DocumentManager::flush()</code> is never called implicitly by Doctrine. You
always have to trigger it manually.</p>
<h3 class="section-header" id="title.1.7.2"><a href="#title.1.7.2">Synchronizing New and Managed Documents<i class="fas fa-link"></i></a></h3>
<p>The flush operation applies to a managed document with the following
semantics:</p>
<ul><li> The document itself is synchronized to the repository using PHPCR
   API calls, only if at least one persistent field has changed;</li>
<li> No PHPCR API calls are executed if the document did not change.</li>
</ul>

<p>The flush operation applies to a new document with the following
semantics:</p>
<ul><li>The document itself is synchronized to the repository using
  PHPCR API calls.</li>
</ul>

<p>For all (initialized) relationships of the new or managed document
the following semantics apply to each associated document X:</p>
<ul><li> If X is new and persist operations are configured to cascade on
   the relationship, X will be persisted;</li>
<li> If X is new and no persist operations are configured to cascade
   on the relationship, an exception will be thrown as this indicates
   a programming error;</li>
<li> If X is removed and persist operations are configured to cascade
   on the relationship, an exception will be thrown as this indicates
   a programming error (X would be re-persisted by the cascade);</li>
<li> If X is detached and persist operations are configured to
   cascade on the relationship, an exception will be thrown (This leads
   to the same result as passing X to persist()).</li>
</ul>

<h3 class="section-header" id="title.1.7.3"><a href="#title.1.7.3">Synchronizing Removed Documents<i class="fas fa-link"></i></a></h3>
<p>The flush operation applies to a removed document by deleting its
persistent state from the repository. No cascade options are relevant
for removed documents on flush, the cascade remove option is already
executed during <code>DocumentManager::remove($document)</code>.</p>
<h3 class="section-header" id="title.1.7.4"><a href="#title.1.7.4">The size of a Unit of Work<i class="fas fa-link"></i></a></h3>
<p>The size of a Unit of Work mainly depends on the number of managed
documents at a particular point in time.</p>
<h3 class="section-header" id="title.1.7.5"><a href="#title.1.7.5">The cost of flushing<i class="fas fa-link"></i></a></h3>
<p>How costly a flush operation is, mainly depends on two factors:</p>
<ul><li> The size of the document manager's current Unit of Work;</li>
<li> The configured change tracking policies.</li>
</ul>

<p>You can get the size of a Unit of Work as follows:</p>
<pre><code class="">$uowSize = $dm-&gt;getUnitOfWork()-&gt;size();
</code></pre>
<p>The size represents the number of managed documents in the Unit of
Work. This size affects the performance of flush() operations due
to change tracking (see &quot;Change Tracking Policies&quot;) and, of course,
memory consumption, so you may want to check it from time to time
during development.</p>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>Do not invoke <code>flush</code> after every change to a document
or every single invocation of persist/remove/merge/... This is an
anti-pattern and unnecessarily reduces the performance of your
application. Instead, form units of work that operate on your
documents and call <code>flush</code> when you are done. While serving a
single HTTP request there should be usually no need for invoking
<code>flush</code> more than 0-2 times.</p>
</div>
<h3 class="section-header" id="title.1.7.6"><a href="#title.1.7.6">Direct Access to a Unit of Work<i class="fas fa-link"></i></a></h3>
<p>You can get direct access to the Unit of Work by calling
<code>DocumentManager::getUnitOfWork()</code>. This will return the UnitOfWork
instance the <code>DocumentManager</code> is currently using:</p>
<pre><code class="">$uow = $em-&gt;getUnitOfWork();
</code></pre>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>Directly manipulating a UnitOfWork is not recommended.
When working directly with the UnitOfWork API, respect methods
marked as INTERNAL by not using them and carefully read the API
documentation.</p>
</div>
<h3 class="section-header" id="title.1.7.7"><a href="#title.1.7.7">Document State<i class="fas fa-link"></i></a></h3>
<p>As outlined in the architecture overview, a document can be in one of
four possible states: NEW, MANAGED, REMOVED, DETACHED. If you
explicitly need to find out what the current state of a document is
in the context of a certain <code>DocumentManager</code> you can ask the
underlying <code>UnitOfWork</code>:</p>
<pre><code class="">switch ($dm-&gt;getUnitOfWork()-&gt;getDocumentState($document)) {
    case UnitOfWork::STATE_MANAGED:
        ...
    case UnitOfWork::STATE_REMOVED:
        ...
    case UnitOfWork::STATE_DETACHED:
        ...
    case UnitOfWork::STATE_NEW:
        ...
}
</code></pre>
<p>The states mean the following:</p>
<ul><li><strong>MANAGED</strong>: The document is associated with a <code>DocumentManager</code>
  and it is not scheduled for removal.</li>
<li><strong>REMOVED</strong>: The document has been passed to <code>DocumentManager::remove()</code>
  but no flush operation executing the removal was triggered yet. A
  REMOVED document is still associated with a <code>DocumentManager</code>
  until the next flush operation.</li>
<li><strong>DETACHED</strong>: The document has persistent state and identity but is
  currently not associated with a <code>DocumentManager</code>.</li>
<li><strong>NEW</strong>: The document has no persistent state and identity
  and is not associated with a <code>DocumentManager</code> (for example those
  just created via the &quot;new&quot; operator).</li>
</ul>

<a id="workingobjects-query"></a>
<h2 class="section-header" id="title.1.8"><a href="#title.1.8">Querying<i class="fas fa-link"></i></a></h2>
<p>Doctrine PHPCR-ODM provides the following ways, in increasing level of
power and flexibility, to query for persisted documents. You should
always start with the simplest one that suits your needs.</p>
<h3 class="section-header" id="title.1.8.1"><a href="#title.1.8.1">By Primary Key<i class="fas fa-link"></i></a></h3>
<p>The most basic way to query for a persisted document is by its
identifier (PHPCR path) using the
<code>DocumentManager::find(null, $id)</code> method. Here is an
example:</p>
<pre><code class="">/** @var $em DocumentManager */
$user = $em-&gt;find('MyProject\Domain\User', $id);
</code></pre>
<p>The return value is either the found document instance or null if no
instance could be found with the given identifier.</p>
<p>If you need several documents and know their paths, you can have a considerable
performance gain by using <code>DocumentManager::findMany(null, $ids)</code> as then
all those documents are loaded from the repository in one request.</p>
<p>You can also specify the class name instead of null to filter to only find
instances of that class. If you go through the repository for a document class
this is equivalent to calling find on the <code>DocumentManager</code> with that document
class.</p>
<h3 class="section-header" id="title.1.8.2"><a href="#title.1.8.2">By Simple Conditions<i class="fas fa-link"></i></a></h3>
<p>To query for one or more documents based on several conditions that
form a logical conjunction, use the <code>findBy</code> and <code>findOneBy</code>
methods on a repository as follows:</p>
<pre><code class="">/** @var $dm DocumentManager */

// All users that are 20 years old
$users = $dm-&gt;getRepository('MyProject\Domain\User')-&gt;findBy(array('age' =&gt; 20));

// All users that are 20 years old and have a surname of 'Miller'
$users = $dm-&gt;getRepository('MyProject\Domain\User')-&gt;findBy(array('age' =&gt; 20, 'surname' =&gt; 'Miller'));

// A single user by its nickname
$user = $dm-&gt;getRepository('MyProject\Domain\User')-&gt;findOneBy(array('nickname' =&gt; 'romanb'));
</code></pre>
<div class="alert warning bg-light-yellow text-dark border"><i class="fas fa-exclamation-circle text-warning mr-2"></i><p>Note that due to the nature of PHPCR, the primary identifier is no field.
You can thus not use <code>findBy(array('id' =&gt; '/my/path'))</code> but should
pass the ID into the <code>find</code> method. There is also findMany if you
need to fetch several documents.</p>
</div>
<p>You can also query by references through the repository:</p>
<pre><code class="">$number = $dm-&gt;find('MyProject\Domain\Phonenumber', '/path/to/phone/number');
$user = $dm-&gt;getRepository('MyProject\Domain\User')-&gt;findOneBy(array('phone' =&gt; $number-&gt;getUuid()));
</code></pre>
<p>Be careful that this only works by passing the uuid of the associated
document, not yet by passing the associated document itself.</p>
<p>The <code>DocumentRepository::findBy()</code> method additionally accepts orderings,
limit and offset as second to fourth parameters:</p>
<pre><code class="">$tenUsers = $dm
    -&gt;getRepository('MyProject\Domain\User')
    -&gt;findBy(array('age' =&gt; 20), array('name' =&gt; 'ASC'), 10, 0);
</code></pre>
<div class="alert note bg-light-yellow text-dark border"><i class="fas fa-sticky-note text-primary mr-2"></i><p>The ORM has a shortcut for querying by one field, using the <code>__call</code>
handler. In PHPCR-ODM this is not yet implemented, so the rest of this
section does not work yet.</p>
</div>
<p>A DocumentRepository also provides a mechanism for more concise
calls through its use of <code>__call</code>. Thus, the following two
examples are equivalent:</p>
<pre><code class="">// A single user by its nickname
$user = $dm-&gt;getRepository('MyProject\Domain\User')-&gt;findOneBy(array('nickname' =&gt; 'romanb'));

// A single user by its nickname (__call magic)
$user = $dm-&gt;getRepository('MyProject\Domain\User')-&gt;findOneByNickname('romanb');

</code></pre>
<h3 class="section-header" id="title.1.8.3"><a href="#title.1.8.3">By Lazy Loading<i class="fas fa-link"></i></a></h3>
<p>Whenever you have a managed document instance at hand, you can
traverse and use any associations of that document that are
configured LAZY as if they were in-memory already. Doctrine will
automatically load the associated documents on demand through the
concept of lazy-loading.</p>
<h3 class="section-header" id="title.1.8.4"><a href="#title.1.8.4">By Query Builder<i class="fas fa-link"></i></a></h3>
<p>PHPCR-ODM provides a query builder that wraps around native PHPCR queries.
See <a href="query-builder.html">The QueryBuilder</a>.</p>
<h3 class="section-header" id="title.1.8.5"><a href="#title.1.8.5">By Native Queries<i class="fas fa-link"></i></a></h3>
<p>PHPCR-ODM has no DQL (yet), but you can query using the JCR-SQL2 query
language or the JCR-QOM to build a query object tree.</p>
<p>You can create your SQL2 query by calling <code>DocumentManager::createPhpcrQuery</code>
with the query as string, or get the phpcr-utils query builder by calling
<code>DocumentManager::createPhpcrQueryBuilder</code>. You can either execute that query
to get raw PHPCR nodes, or pass a PHPCR query to
<code>DocumentManager::getDocumentsByPhpcrQuery</code> to get documents.</p>
<h3 class="section-header" id="title.1.8.6"><a href="#title.1.8.6">Custom Repositories<i class="fas fa-link"></i></a></h3>
<p>By default the <code>DocumentManager</code> returns a default implementation of
<code>Doctrine\ODM\PHPCR\DocumentRepository</code> when you call
<code>DocumentManager::getRepository($documentClass)</code>. You can overwrite
this behaviour by specifying the class name of your own Document
Repository in the Annotation, XML or YAML metadata.</p>
<p>In applications that require lots of specialized queries, using a
custom repository is the recommended way of grouping these queries
in a central location:</p>
<pre><code class="">namespace MyDomain\Model;

use Doctrine\ODM\PHPCR\DocumentRepository;

/**
 * @PHPCR\Document(repositoryClass=&quot;MyDomain\Model\UserRepository&quot;)
 */
class User
{

}

class UserRepository extends DocumentRepository
{
    public function getAllAdminUsers()
    {
        $qb = $this-&gt;dm-&gt;getQueryBuilder();
        // ... build some fancy query
        return $qb-&gt;getQuery()-&gt;getResult();
    }
}
</code></pre>
<p>You can access your repository now by calling:</p>
<pre><code class="">/** @var $dm DocumentManager */

$admins = $dm-&gt;getRepository('MyDomain\Model\User')-&gt;getAllAdminUsers();
</code></pre>
</body>
</html>                    </main>

        <footer class="footer">
            <div class="container">
                <i class="fa fa-copyright"></i> 2018 Doctrine
            </div>
        </footer>

        <script type="text/javascript">
            // When the user scrolls down 20px from the top of the document, show the button
            window.onscroll = function() {scrollFunction()};

            function scrollFunction() {
                if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                    document.getElementById('back-to-top').style.display = "block";
                } else {
                    document.getElementById('back-to-top').style.display = "none";
                }
            }

            // When the user clicks on the button, scroll to the top of the document
            function topFunction() {
                document.body.scrollTop = 0; // For Safari
                document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }
        </script>

        <button onclick="topFunction()" id="back-to-top" title="Go to top">Top</button>

        <script
          src="https://code.jquery.com/jquery-3.3.1.min.js"
          integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
          crossorigin="anonymous"></script>

        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>

        <script
            src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>

        <script src="https://new.doctrine-project.org/components/highlightjs/highlight.pack.js?9"></script>
        <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0"></script>

        
                    <script type="text/javascript">
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-288343-7', 'auto');
                ga('send', 'pageview');
            </script>
        
        
            </body>
</html>
