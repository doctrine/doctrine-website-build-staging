<!DOCTYPE html>
<html>
    <head>
        <title>カラム - Doctrine - PHP Database Tools</title>

        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="theme-color" content="#ffffff">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <meta name="description" content="The Doctrine Project is the home to several PHP libraries primarily focused on database storage and object mapping. The core projects are the Object Relational Mapper (ORM) and the Database Abstraction Layer (DBAL) it is built upon.
">

        <meta name="keywords" content="php,mysql,orm,dbal,database,mongodb,odm,annotations,migrations,cache,couchdb">

                    <meta name="robots" content="noindex">
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.8/css/all.css" integrity="sha384-3AB7yXWz4OeoZcPbieVW64vVXEwADiYyAEhwilzWsLw+9FgqpyjjStpPnpBO8o8S" crossorigin="anonymous">

        <link href="https://staging.doctrine-project.org/css/style.css?c8b404" rel="stylesheet" type="text/css" />

        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0/dist/instantsearch.min.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0/dist/instantsearch-theme-algolia.min.css">

        <link rel="stylesheet" href="https://staging.doctrine-project.org/css/railscasts.css?62eb49" />

        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">

        <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://staging.doctrine-project.org/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://staging.doctrine-project.org/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://staging.doctrine-project.org/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://staging.doctrine-project.org/images/apple-touch-icon-144x144.png" />
        <link rel="apple-touch-icon-precomposed" sizes="60x60" href="https://staging.doctrine-project.org/images/apple-touch-icon-60x60.png" />
        <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://staging.doctrine-project.org/images/apple-touch-icon-120x120.png" />
        <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://staging.doctrine-project.org/images/apple-touch-icon-76x76.png" />
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://staging.doctrine-project.org/images/apple-touch-icon-152x152.png" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-196x196.png" sizes="196x196" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-96x96.png" sizes="96x96" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-32x32.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-16x16.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="https://staging.doctrine-project.org/images/favicon-128.png" sizes="128x128" />
        <meta name="application-name" content="Doctrine"/>
        <meta name="msapplication-TileColor" content="#FFFFFF" />
        <meta name="msapplication-TileImage" content="https://staging.doctrine-project.org/images/mstile-144x144.png" />
        <meta name="msapplication-square70x70logo" content="https://staging.doctrine-project.org/images/mstile-70x70.png" />
        <meta name="msapplication-square150x150logo" content="https://staging.doctrine-project.org/images/mstile-150x150.png" />
        <meta name="msapplication-wide310x150logo" content="https://staging.doctrine-project.org/images/mstile-310x150.png" />
        <meta name="msapplication-square310x310logo" content="https://staging.doctrine-project.org/images/mstile-310x310.png" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@doctrineorm" />
        <meta name="twitter:creator" content="@doctrineorm" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://staging.doctrine-project.org/projects/doctrine1/ja/latest/manual/defining-models.html" />
        <meta property="og:title" content="カラム - Doctrine - PHP Database Tools" />
        <meta property="og:description" content="The Doctrine Project is the home to several PHP libraries primarily focused on database storage and object mapping. The core projects are the Object Relational Mapper (ORM) and the Database Abstraction Layer (DBAL) it is built upon.
" />
        <meta property="og:image" content="https://staging.doctrine-project.org/images/og.png" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="1200" />

        <link rel="alternate" type="application/atom+xml" href="https://staging.doctrine-project.org/atom.xml" title="Doctrine activity feed" />

        <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "Organization",
            "url": "https://staging.doctrine-project.org",
            "logo": "https://staging.doctrine-project.org/images/doctrine-logo.svg"
        }
        </script>

        <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "WebSite",
            "url": "https://staging.doctrine-project.org",
            "potentialAction": {
                "@type": "SearchAction",
                "target": "https://staging.doctrine-project.org?q={search_term_string}",
                "query-input": "required name=search_term_string"
            }
        }
        </script>

        <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "Organization",
            "name": "Doctrine",
            "url": "https://staging.doctrine-project.org",
            "sameAs": [
                "https://twitter.com/doctrineorm"
            ]
        }
        </script>

        
        
            </head>
    <body>
                    <nav class="navbar navbar-expand-lg navbar-dark sticky-top bg-dark flex-md-nowrap">
                <a class="navbar-brand text-hide" href="https://staging.doctrine-project.org/"><img src="https://staging.doctrine-project.org/images/doctrine-logo.svg?6c0dab" />Doctrine</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarCollapse">
                    <ul class="navbar-nav mr-auto">
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="https://staging.doctrine-project.org/projects.html" id="navbarProjectsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                Projects
                            </a>
                            <div class="dropdown-menu" aria-labelledby="navbarProjectsDropdown">
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/annotations.html">Annotations</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/cache.html">Cache</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/coding-standard.html">Coding Standard</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/collections.html">Collections</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/common.html">Common</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/dbal.html">DBAL</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/event-manager.html">Event Manager</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/inflector.html">Inflector</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/lexer.html">Lexer</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/migrations.html">Migrations</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/mongodb.html">MongoDB</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/mongodb-odm.html">MongoDB ODM</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/orm.html">ORM</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/persistence.html">Persistence</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/phpcr-odm.html">PHPCR ODM</a>
                                                                    <a class="dropdown-item notranslate" href="https://staging.doctrine-project.org/projects/reflection.html">Reflection</a>
                                                                <a class="dropdown-item bg-secondary text-white font-weight-bold" href="https://staging.doctrine-project.org/projects.html">View All</a>
                            </div>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="https://staging.doctrine-project.org/contribute/" id="navbarContributeDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Contribute</a>

                            <div class="dropdown-menu" aria-labelledby="navbarContributeDropdown">
                                <a class="dropdown-item" href="https://staging.doctrine-project.org/contribute/">Contributor Workflow</a>
                                <a class="dropdown-item" href="https://staging.doctrine-project.org/contribute/maintainer/">Maintainer Workflow</a>
                                <a class="dropdown-item" href="https://staging.doctrine-project.org/contribute/website/">Contribute to Website</a>
                            </div>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/community/">Community</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/blog/">Blog</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="https://staging.doctrine-project.org/team/">Team</a>
                        </li>
                    </ul>

                    <div class="google-translate-dropdown dropdown show d-inline-block mr-2">
                        <a class="btn btn-primary dropdown-toggle" href="#" role="button" id="translateDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                            Translate
                        </a>

                        <div class="dropdown-menu" aria-labelledby="translateDropdown">
                            <div class="dropdown-item" id="google_translate_element">Loading...</div>
                        </div>
                    </div>

                    <div id="search-box">
                        <!-- SearchBox widget will appear here -->
                    </div>
                </div>
            </nav>

            <div class="search-results rounded">
                <div id="hits">
                    <!-- Hits widget will appear here -->
                </div>

                <a href="https://www.algolia.com" target="_blank"><img src="https://staging.doctrine-project.org/images/search-by-algolia.png" class="float-right" style="width: 150px;" /></a>
            </div>
        
            <main role="main" class="container-wrapper container">
                    
<p></p>
<p>以前述べたように、Doctrineの最も低いレベルにおいてスキーマはデータベーステーブル用のスキーマメタデータをマッピングするPHPクラスの一式で表現されます。</p>
<p>この章ではPHPコードを使用してスキーマ情報をマッピングする方法を詳しく説明します。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">カラム<i class="fas fa-link"></i></a></h1>
<p>データベースの互換性の問題の1つは多くのデータベースにおいて返されるクエリの結果セットが異なることです。MySQL
はフィールドの名前はそのままにします。このことは<code>&quot;SELECT myField FROM
...&quot;</code>形式のクエリを発行する場合、結果セットは<code>myField</code>のフィールドを含むことを意味します。</p>
<p>不幸にして、これはMySQLとその他のいくつかのデータベースだけの挙動です。例えばPostgresはすべてのフィールド名を小文字で返す一方でOracleは大文字ですべてのフィールド名を返します。&quot;だから何？Doctrineを使う際にこれがどのような方法で影響を及ぼすの？&quot;、と疑問に思うかもしれません。幸いにして、この問題を悩む必要はまったくありません。</p>
<p>Doctrineはこの問題を透過的に考慮します。Record派生クラスを定義し<code>myField</code>という名前のフィールドを定義する場合、MySQLもしくはPostgresもしくはOracleその他を使おうが、<code>`record-&gt;myField</code> (もしくは<code>`\ record['myField']</code>、好きな方で)を通してアクセスできることを意味します。
要するに:
under\_scores(アンダースコア)、camelCase(キャメルケース)もしくは望む形式を使用してフィールドを好きなように名付けることができます。</p>
<blockquote><p><strong>NOTE</strong>
Doctrineにおいてカラムとカラムのエイリアスは大文字と小文字を区別します。DQLクエリでカラムを使用するとき、カラム/フィールドの名前はモデルの定義のケースにマッチしなければなりません。</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">カラムのエイリアス<i class="fas fa-link"></i></a></h2>
<p>Doctrineはカラムのエイリアスを定義する方法を提供します。これはデータベースのロジックからアプリケーションのロジックを分離するのを維持したい場合にとても役に立ちます。例えば
データベースフィールドの名前を変更したい場合、アプリケーションで変更する必要のあるのはカラムの定義だけです。</p>
<blockquote><p>// models/Book.php</p>
</blockquote>
<p>class Book extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('bookTitle as title', 'string');
} }</p>
<p>下記のコードはYAMLフォーマットのサンプルです。[doc yaml-schema-files
:name]の章でYAMLの詳しい情報を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Book: columns: bookTitle: name: bookTitle as title type: string</p>
<p>Now
データベースのカラムはbookTitleという名前ですがtitleを使用してオブジェクトのプロパティにアクセスできます。</p>
<blockquote><p>// test.php</p>
</blockquote>
<p>// ... $book = new Book(); $book-&gt;title = 'Some book'; $book-&gt;save();</p>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">デフォルトの値<i class="fas fa-link"></i></a></h2>
<p>Doctrineはすべてのデータ型のデフォルト値をサポートします。デフォルト値がレコードのカラムに付属するとき2つのことを意味します。まずこの値はすべての新しく作成されたRecordに添付されDoctrineがデータベースを作成するときにcreate
tableステートメントにデフォルト値を含めます。</p>
<blockquote><p>// models/generated/BaseUser.php</p>
</blockquote>
<p>class User extends BaseUser { public function setTableDefinition() {
$this-&gt;hasColumn('username', 'string', 255, array('default' =&gt; 'default
username'));</p>
<div class="console"><pre><code class="console">// ...


..</code></pre></div>
<p>}</p>
<p>YAMLフォーマットのサンプルコードは次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>User: # ... columns: username: type: string(255) default: default
username # ...</p>
<p>真新しいUserレコードで名前を表示するときデフォルト値が表示されます:</p>
<blockquote><p>// test.php</p>
</blockquote>
<p>// ... $user = new User(); echo $user-&gt;username; //
デフォルトのユーザー名</p>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">データの型<i class="fas fa-link"></i></a></h2>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">はじめに<i class="fas fa-link"></i></a></h3>
<p>データベースフィールドに保存できる情報用にすべてのDBMSはデータの型の複数の選択肢を提供します。しかしながら、利用可能なデータ型の一式はDBMSによって異なります。</p>
<p>DoctrineによってサポートされるDBMSでインターフェイスを簡略化するために、内在するDBMSにおいてアプリケーションが個別にアクセスできるデータ型の基本セットが定義されました</p>
<p>Doctrineのアプリケーションプログラミングインターフェイスはデータベースオプションを管理する際にデータ型のマッピングを考慮します。それぞれのドライバを使用して内在するDBMSに送るかつDBMSから受け取るものを変換することも可能です。</p>
<p>次のデータ型の例ではDoctrineの<code>createTable()</code>メソッドを使います。データ型セクションの最後の配列の例では選んだDBMSでポータブルなテーブルを作成するために<code>createTable()</code>メソッドを使うことがあります(何のDBMSが適切にサポートされているか理解するためにDoctrineのメインドキュメントを参照してくださるようお願いします)。次の例ではインデックスの作成と維持はカバーされないことも注意してください。この章はデータ型と適切な使い方のみを考慮します。</p>
<p>アプリケーションレベルでバリデートされた長さ(Doctrineバリデータでバリデートされた長さ)と同様に、カラムの長さはデータベースレベルで影響があることを気を付けてください。</p>
<p>例 1.
'string'型と長さ3000の'content'という名前のカラムはデータベースレベルの長さ4000を持つ'TEXT'データベースの型になります。しかしながらレコードがバリデートされるとき最大長が3000である'content'カラムを持つことのみ許可されます。</p>
<p>例 2.
多くのデータベースでは'integer'型と長さ1を持つカラムは'TINYINT'になります。</p>
<p>一般的に
Doctrineは指定された長さによってどのinteger/string型を使うのか知っているほど賢いです。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">型修飾子<i class="fas fa-link"></i></a></h3>
<p>Doctrine APIの範囲内で
オプションのテーブルデザインに役立つように設計された修飾子が少しあります:</p>
<ul><li class="dash"> notnull修飾子</li>
<li class="dash"> length修飾子</li>
<li class="dash"> default修飾子</li>
<li class="dash"> フィールド定義用のunsigned修飾子、integerフィールド型に対して
   すべてのDBMSはこの修飾子をサポートしません。</li>
<li class="dash"> collation修飾子(すべてのドライバでサポートされない)</li>
<li class="dash"> フィールド定義用の固定長修飾子</li>
</ul>

<p>上記の内容に基づいて話しを進めると、特定の使い方のシナリオ用の特定のフィールドの型を作成するために、修飾子がフィールド定義を変更することが言えます。DBMSのフィールド値の定義によって、フィールド上でデフォルトのDBMS
NOT NULL
Flagをtrueもしくはfalseに設定するためにnotnull修飾子は次の方法で使われます:
PostgreSQLにおいて&quot;NOT NULL&quot;の定義は&quot;NOT
NULL&quot;に設定される一方で、(例えば)MySQLでは&quot;NULL&quot;オプションは&quot;NO&quot;に設定されます。&quot;NOT
NULL&quot;フィールド型を定義するために、定義配列に追加パラメータを追加するだけです(例は次のセクションを参照)。</p>
<blockquote><p>'sometime' = array( 'type' =&gt; 'time', 'default' =&gt; '12:34:05',</p>
</blockquote>
<p>'notnull' =&gt; true, ),</p>
<p>上記の例を利用することで、デフォルトのフィールド演算子も研究できます。フィールド用のデフォルト値はnotnull演算子と同じ方法で設定されます。この値はDBMSがテキストフィールド用にサポートする文字集合、フィールドのデータ型用の他の有効な値に設定されます。上記の例において、&quot;Time&quot;データ型に対して有効な時間である'12:34:05'を指定しました。datetimeと同じく日付と時間を設定するとき、調べて選択したDBMSのエポックの範囲に収まるようにすべきであることを覚えておいてください。さもなければエラーを診断するのが困難な状況に遭遇します！</p>
<blockquote><p>'sometext' = array( 'type' =&gt; 'string', 'length' =&gt; 12, ),</p>
</blockquote>
<p>上記の例ではデータベースのテーブルで長さ12のフィールドを変更する文字が作られます。長さの定義が省略される場合、Doctrineは指定されたデータ型で許容される最大長を作成されます。これはフィールドの型とインデックス作成において問題を引き起こす可能性があります。ベストプラクティスはすべてもしくは大抵のフィールドに対して長さを定義することです。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">論理型<i class="fas fa-link"></i></a></h3>
<p>論理型は0か1の2つの値のどちらかだけを表します。効率性の観点からDBMSドライバの中には単独の文字のテキストフィールドで整数型を実装するものがあるのでこれらの論理型を整数型として保存されることを想定しないでください。この型のフィールドに割り当てできる3番目の利用可能な値としてnullを使うことで三値論理は可能です。</p>
<blockquote><p><strong>NOTE</strong>
次のいくつかの例では使ったり試したりすることを想定していません。これらは単にPHPコードもしくはYAMLスキーマファイルを利用してDoctrineの異なるデータ型を使う方法を示すことだけを目的としています。</p>
<p>ss Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('booltest', 'boolean'); } }</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細内容を見ることができます:</p>
<blockquote><p>Test: columns: booltest: boolean</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">整数型<i class="fas fa-link"></i></a></h3>
<p>整数型はPHPの整数型と同じです。それぞれのDBMSが扱える大きさの整数型の値を保存します。</p>
<p>オプションとしてこの型のフィールドは符号なしの整数として作成されますがすべてのDBMSはこれをサポートしません。それゆえ、このようなオプションは無視されることがあります。本当にポータルなアプリケーションはこのオプションの利用可能性に依存すべきではありません。</p>
<p>整数型はカラムの長さによって異なるデータベースの型にマッピングされます。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('integertest', 'integer', 4,
array( 'unsigned' =&gt; true ) ); } }</p>
<p>YAMLフォーマットでの例です。[doc yaml-schema-files
:name]の章っでYAMLの詳細情報を読むことができます:</p>
<blockquote><p>Test: columns: integertest: type: integer(4) unsigned: true</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">浮動小数点型<i class="fas fa-link"></i></a></h3>
<p>浮動小数点のデータ型は10進法の浮動小数点数を保存できます。このデータ型は高い精度を必要としない大きなスケールの範囲の数値を表現するのに適しています。スケールと精度に関してデータベースに保存される値の制限は使用されるDBMSに依存します。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('floattest', 'float'); } }</p>
<p>下記のコードはYAMLフォーマットでの例です。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を読むことができます:</p>
<blockquote><p>Test: columns: floattest: float</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">小数型<i class="fas fa-link"></i></a></h3>
<p>小数型のデータは固定精度の小数を保存できます。このデータ型は高い正確度と精度を必要とする数値を表現するのに適しています。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('decimaltest', 'decimal'); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を学ぶことができます:</p>
<blockquote><p>Test: columns: decimaltest: decimal</p>
</blockquote>
<p>他のカラムの<code>length</code>を設定するように小数の長さを指定することが可能で3番目の引数でオプションとして<code>scale</code>を指定できます:</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('decimaltest', 'decimal', 18,
array( 'scale' =&gt; 2 ) ); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報をみることができます:</p>
<blockquote><p>Test: columns: decimaltest: type: decimal(18) scale: 2</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">文字列型<i class="fas fa-link"></i></a></h3>
<p>テキストデータ型では長さに対して2つのオプションが利用可能です:
1つは明示的に制限された長さでもう一つはデータベースが許容する限りの大きさの未定義の長さです。</p>
<p>効率の点で制限オプション付きの長さは大抵の場合推奨されます。未定義の長さオプションはとても大きなフィールドを許可しますがインデックスとnullの利用を制限することがあり、その型のフィールド上でのソートを許可しません。</p>
<p>この型のフィールドは8ビットの文字を扱うことができます。文字列の値をこの型に変換することでドライバはDBMSで特別な意味を持つ文字のエスケープを考慮します。</p>
<p>デフォルトではDoctrineは可変長の文字型を使用します。固定長の型が使われる場合、fixed修飾子を通してコントロールできます。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('stringtest', 'string', 200,
array( 'fixed' =&gt; true ) ); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を見ることができます:</p>
<blockquote><p>Test: columns: stringtest: type: string(200) fixed: true</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">配列<i class="fas fa-link"></i></a></h3>
<p>これはPHPの'array'型と同じです。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('arraytest', 'array', 10000); }
}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を見ることができます:</p>
<blockquote><p>Test: columns: arraytest: array(10000)</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">オブジェクト<i class="fas fa-link"></i></a></h3>
<p>Doctrineはオブジェクトをカラム型としてサポートします。基本的にオブジェクトをフィールドに設定可能でDoctrineはそのオブジェクトのシリアライズ/アンシリアライズを自動的に処理します。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('objecttest', 'object'); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細情報を読むことができます:</p>
<blockquote><p>Test: columns: objecttest: object</p>
<blockquote><p><strong>NOTE</strong>
配列とオブジェクト型はデータベースで永続化するときはデータをシリアライズしデータベースから引き出すときはデータをアンシリアライズします</p>
</blockquote>
</blockquote>
<hr />
<a class="section-anchor" id="blob" name="blob"></a><h3 class="section-header"><a href="#blob">blob<i class="fas fa-link"></i></a></h3>
<p>blob(Binary Large
OBject)データ型は、通常はファイルに保存されるデータのようにテキストフィールドに大きすぎる未定義の長さのデータを保存することを意味します。</p>
<p>内在するDBMSが&quot;全文検索&quot;として知られる機能をサポートしない限りblobフィールドはエリーの検索句(<code>WHERE</code>)のパラメータを使用することを意味しません。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('blobtest', 'blob'); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: blobtest: blob</p>
</blockquote>
<hr />
<a class="section-anchor" id="clob" name="clob"></a><h3 class="section-header"><a href="#clob">clob<i class="fas fa-link"></i></a></h3>
<p>clob (Character Large
OBject)データ型は、通常はファイルに保存されるデータのように、テキストフィールドで保存するには大きすぎる未定義の長さのデータを保存することを意味します。</p>
<p>blogフィールドがデータのすべての型を保存するのが想定されているのに対してclobフィールドは印字可能なASCII文字で構成されるデータのみを保存することを想定しています。</p>
<p>内在するDBMSが&quot;全文検索&quot;として知られる機能をサポートしない限りclobフィールドはクエリ検索句(WHERE)のパラメータとして使われることが想定されています。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('clobtest', 'clob'); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: clobtest: clob</p>
</blockquote>
<hr />
<a class="section-anchor" id="timestamp" name="timestamp"></a><h3 class="section-header"><a href="#timestamp">timestamp<i class="fas fa-link"></i></a></h3>
<p>timestampデータ型は日付と時間のデータ型の組み合わせに過ぎません。timestamp型の値の表記は日付と時間の文字列の値は1つのスペースで連結することで実現されます。それゆえ、フォーマットのテンプレートは<code>YYYY-MM-DD
HH:MI:SS</code>です。表される値は日付と時間データ型で説明したルールと範囲に従います。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('timestamptest', 'timestamp'); }
}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: timestamptest: timestamp</p>
</blockquote>
<hr />
<a class="section-anchor" id="time" name="time"></a><h3 class="section-header"><a href="#time">time<i class="fas fa-link"></i></a></h3>
<p>timeデータ型はその日の与えられた瞬間の時間を表します。DBMS独自の時間の表記もISO-8601標準に従ってテキストの文字列を使用することで実現できます。</p>
<p>日付の時間用にISO-8601標準で定義されたフォーマットはHH:MI:SSでHHは時間で00から23まででMIとSSは分と秒で00から59までです。時間、分と秒は10より小さな数値の場合は左側に0が詰められます。</p>
<p>DBMSの中にはネイティブで時間フォーマットをサポートするものがありますが、DBMSドライバの中にはこれらを整数もしくはテキストの文字列として表現しなければならないものがあります。ともかく、この型のフィールドによるソートクエリの結果と同じように時間の値の間で比較することは常に可能です。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('timetest', 'time'); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: timetest: time</p>
</blockquote>
<hr />
<a class="section-anchor" id="date" name="date"></a><h3 class="section-header"><a href="#date">date<i class="fas fa-link"></i></a></h3>
<p>dateデータ型は年、月と日にちのデータを表します。DBMS独自の日付の表記はISO-8601標準の書式のテキスト文字列を使用して実現されます。</p>
<p>日付用にISO-8601標準で定義されたフォーマットはYYYY-MM-DDでYYYYは西暦の数字(グレゴリオ暦)、MMは01から12までの月でDDは01か31までの日の数字です。10より小さい月の日にちの数字には左側に0が追加されます。</p>
<p>DBMSの中にはネイティブで日付フォーマットをサポートするものがありますが、他のDBMSドライバではこれらを整数もしくはテキストの値として表現しなければならないことがあります。どの場合でも、この型のフィールドによるソートクエリの結果によって日付の間の比較は常に可能です。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('datetest', 'date'); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: datetest: date</p>
</blockquote>
<hr />
<a class="section-anchor" id="enum" name="enum"></a><h3 class="section-header"><a href="#enum">enum<i class="fas fa-link"></i></a></h3>
<p>Doctrineはunifiedなenum型を持ちます。カラムに対して可能な値は<code>Doctrine_Record::hasColumn()</code>でカラム定義に指定できます。</p>
<blockquote><p><strong>NOTE</strong>
DBMSに対してネイティブのenum型を使用したい場合次の属性を設定しなければなりません:</p>
<p>nn-&gt;setAttribute(Doctrine\_Core::ATTR\_USE\_NATIVE\_ENUM, true);</p>
</blockquote>
<p>次のコードはenumの値を指定する方法の例です:</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('enumtest', 'enum', null,
array('values' =&gt; array('php', 'java', 'python')) ); } }</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: enumtest: type: enum values: [php, java, python]</p>
</blockquote>
<hr />
<a class="section-anchor" id="gzip" name="gzip"></a><h3 class="section-header"><a href="#gzip">gzip<i class="fas fa-link"></i></a></h3>
<p>gzipデータ型は存続するときに自動的に圧縮取得されたときに解凍される以外は文字列と同じです。ビットマップ画像など、大きな圧縮率でデータを保存するときにこのデータ型は役に立ちます。</p>
<blockquote><p>class Test extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('gziptest', 'gzip'); } }</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Test: columns: gziptest: gzip</p>
<blockquote><p><strong>NOTE</strong>
内部ではgzipカラム型の内容の圧縮と解凍を行うために[http://www.php.net/gzcompress
圧縮]系のPHP関数が使われています。</p>
</blockquote>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">例<i class="fas fa-link"></i></a></h2>
<p>次の定義を考えましょう:</p>
<blockquote><p>class Example extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('id', 'string', 32, array(
'type' =&gt; 'string', 'fixed' =&gt; 1, 'primary' =&gt; true, 'length' =&gt; '32' )
);</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->hasColumn('someint', 'integer', 10, array(
        'type' => 'integer',
        'unsigned' => true,
        'length' => '10'
    )
);

<span class="noselect">$ </span>this->hasColumn('sometime', 'time', 25, array(
        'type' => 'time',
        'default' => '12:34:05',
        'notnull' => true,
        'length' => '25'
    )
);

<span class="noselect">$ </span>this->hasColumn('sometext', 'string', 12, array(
        'type' => 'string',
        'length' => '12'
    )
);

<span class="noselect">$ </span>this->hasColumn('somedate', 'date', 25, array(
        'type' => 'date',
        'length' => '25'
    )
);

<span class="noselect">$ </span>this->hasColumn('sometimestamp', 'timestamp', 25, array(
        'type' => 'timestamp',
        'length' => '25'
    )
);

<span class="noselect">$ </span>this->hasColumn('someboolean', 'boolean', 25, array(
        'type' => 'boolean',
        'length' => '25'
    )
);

<span class="noselect">$ </span>this->hasColumn('somedecimal', 'decimal', 18, array(
        'type' => 'decimal',
        'length' => '18'
    )
);

<span class="noselect">$ </span>this->hasColumn('somefloat', 'float', 2147483647, array(
        'type' => 'float',
        'length' => '2147483647'
    )
);

<span class="noselect">$ </span>this->hasColumn('someclob', 'clob', 2147483647, array(
        'type' => 'clob',
        'length' => '2147483647'
    )
);

<span class="noselect">$ </span>this->hasColumn('someblob', 'blob', 2147483647, array(
        'type' => 'blob',
        'length' => '2147483647'
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>Example: tableName: example columns: id: type: string(32) fixed: true</p>
</blockquote>
<p>primary: true someint: type: integer(10) unsigned: true sometime: type:
time(25) default: '12:34:05' notnull: true sometext: string(12)
somedate: date(25) sometimestamp: timestamp(25) someboolean: boolean(25)
somedecimal: decimal(18) somefloat: float(2147483647) someclob:
clob(2147483647) someblob: blob(2147483647)</p>
<p>上記の例はPgsqlで次のテーブルが作成します:</p>
<p>\&nbsp; カラム \&nbsp; 型 \ \ <code>id</code> \ <code>character(32)</code> \ \
<code>someint</code> \ <code>integer</code> \ \ <code>sometime</code> \
タイムゾーンなしの<code>time</code> \ \ <code>sometext</code> \
<code>character</code>もしくは<code>varying(12)</code> \ \ <code>somedate</code> \
<code>date</code> \ \ <code>sometimestamp</code> \
タイムゾーンなしの<code>timestamp</code> \ \ <code>someboolean</code> \
<code>boolean</code> \ \ <code>somedecimal</code> \ <code>numeric(18,2)</code> \ \
<code>somefloat</code> \ <code>double</code>の精度 \ \ <code>someclob</code> \ <code>text</code>
\ \ <code>someblob</code> \ <code>bytea</code> \</p>
<p>Mysqlではスキーマは次のデータベーステーブルを作成します:</p>
<p>\&nbsp; フィールド \&nbsp; 型 \ \ <code>id</code> \ <code>char(32)</code> \ \
<code>someint</code> \ <code>integer</code> \ \ <code>sometime</code> \ <code>time</code> \
\ <code>sometext</code> \ <code>varchar(12)</code> \ \ <code>somedate</code> \
<code>date</code> \ \ <code>sometimestamp</code> \ <code>timestamp</code> \ \
<code>someboolean</code> \ <code>tinyint(1)</code> \ \ <code>somedecimal</code> \
<code>decimal(18,2)</code> \ \ <code>somefloat</code> \ <code>double</code> \ \
<code>someclob</code> \ <code>longtext</code> \ \ <code>someblob</code> \ <code>longblob</code>
\</p>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">リレーション<i class="fas fa-link"></i></a></h1>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">はじめに<i class="fas fa-link"></i></a></h2>
<p>Doctrineにおいてすべてのレコードのリレーションは<code>Doctrine\_Record::hasMany</code>、<code>Doctrine_Record::hasOne</code>メソッドで設定されます。Doctrineはほとんどの種類のデータベースリレーションをサポートします
from
一対一のシンプルな外部キーのリレーションから自己参照型のリレーションまでサポートします。</p>
<p>カラムの定義とは異なり<code>Doctrine\_Record::hasMany</code>と<code>Doctrine_Record::hasOne</code>メソッドは<code>setUp()</code>と呼ばれるメソッドの範囲内で設置されます。両方のメソッドは2つの引数を受け取ります:
最初の引数はクラスの名前とオプションのエイリアスを含む文字列で、2番目の引数はリレーションのオプションで構成される配列です。オプションの配列は次のキーを含みます:</p>
<p>\&nbsp; 名前 \&nbsp; オプション \&nbsp; 説明 \ \ <code>local</code> \ No \
リレーションのローカルフィールド。ローカルフィールドはクラスの定義ではリンク付きのフィールド。
\ \ <code>foreign</code> \ No \
リレーションの外部フィールド。外部フィールドはリンク付きのクラスのリンク付きフィールドです。\
\ <code>refClass</code> \ Yes \
アソシエーションクラスの名前。これは多対多のアソシエーションに対してのみ必要です。\
\ <code>owningSide</code>\ Yes \
所有側のリレーションを示すには論理型のtrueを設定します。所有側とは外部キーを所有する側です。2つのクラスの間のアソシエーションにおいて所有側は1つのみです。Doctrineが所有側を推測できないもしくは間違った推測をする場合このオプションが必須であることに注意してください。'local'と'foreign'の両方が識別子(主キー)の一部であるときこれが当てはまります。この方法で所有側を指定することは害になることはありません。\
\ <code>onDelete</code> \ Yes \
Doctrineによってテーブルが適用されるときに<code>onDelete</code>整合アクションが外部キー制約に適用されます。
\ \ <code>onUpdate</code> \ Yes \
Doctrineによってテーブルが作成されたときに<code>onUpdate</code>整合アクションが外部キー制約に適用されます。\
\ <code>cascade</code> \ Yes \
オペレーションをカスケーディングするアプリケーションレベルを指定する。現在削除のみサポートされる
\</p>
<p>最初の例として、<code>Forum\_Board</code>と<code>Forum\_Thread</code>の2つのクラスがあるとします。リレーションが一対多なので、<code>Forum\_Board</code>は多くの<code>Forum\_Threads</code>を持ちます。リレーションにアクセスする際に<code>Forum_</code>を書きたくないので、リレーションのエイリアスを使用しエイリアスの<code>Threads</code>を使用します。</p>
<p>最初に<code>Forum_Board</code>クラスを見てみましょう。これはカラム: 名前,
説明を持ち主キーを指定していないので、Doctrineはidカラムを自動作成します。</p>
<p><code>hasMany()</code>メソッドを使用することで<code>Forum\_Thread</code>クラスへのリレーションを定義します。localフィールドがboardクラスの主キーである一方でforeignフィールドが<code>Forum\_Thread</code>クラスの<code>board_id</code>フィールドです。</p>
<blockquote><p>// models/Forum\_Board.php</p>
</blockquote>
<p>class Forum\_Board extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('name', 'string', 100);
$this-&gt;hasColumn('description', 'string', 5000); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasMany('Forum_Thread as Threads', array(
            'local' => 'id',
            'foreign' => 'board_id'
        )
    );
}</code></pre></div>
<p>}</p>
<blockquote><p><strong>NOTE</strong>
asキーワードが使われていることに注目してください。このことは<code>Forum\_Board</code>が<code>Forum_Thread</code>に定義された多数のリレーションを持ちますが<code>Threads</code>のエイリアスが設定されることを意味します。</p>
</blockquote>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Forum\_Board: columns: name: string(100) description: string(5000)</p>
<p><code>Forum\_Thread</code>クラスの内容を少しのぞいて見ましょう。カラムの内容は適当ですが、リレーションの定義方法に注意をはらってください。それぞれの<code>Thread</code>は1つの<code>Board</code>のみを持つことができるので<code>hasOne()</code>メソッドを使っています。またエイリアスの使い方とlocalカラムが<code>board_id</code>である一方で外部カラムは<code>id</code>カラムであることに注目してください。</p>
<blockquote><p>// models/Forum\_Thread.php</p>
</blockquote>
<p>class Forum\_Thread extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('user\_id', 'integer');
$this-&gt;hasColumn('board\_id', 'integer'); $this-&gt;hasColumn('title',
'string', 200); $this-&gt;hasColumn('updated', 'integer', 10);
$this-&gt;hasColumn('closed', 'integer', 1); }</p>
<div class="console"><pre><code class="console">public function setUp() 
{
    $this->hasOne('Forum_Board as Board', array(
            'local' => 'board_id',
            'foreign' => 'id'
        )
    );

    $this->hasOne('User', array(
            'local' => 'user_id',
            'foreign' => 'id'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Forum\_Thread: columns: user\_id: integer board\_id: integer title:
string(200) updated: integer(10) closed: integer(1) relations: User:
local: user\_id foreign: id foreignAlias: Threads Board: class:
Forum\_Board local: board\_id foreign: id foreignAlias: Threads</p>
<p>これらのクラスを使い始めることができます。プロパティに既に使用した同じアクセサはリレーションに対してもすべて利用できます。</p>
<p>最初に新しいboardを作りましょう:</p>
<blockquote><p>// test.php</p>
</blockquote>
<p>// ... $board = new Forum\_Board(); $board-&gt;name = 'Some board';</p>
<p>boardの元で新しいthreadを作りましょう:</p>
<blockquote><p>// test.php</p>
</blockquote>
<p>// ... $board-&gt;Threads[0]-&gt;title = 'new thread 1';
$board-&gt;Threads[1]-&gt;title = 'new thread 2';</p>
<p>それぞれの<code>Thread</code>はそれぞれのユーザーに関連付ける必要があるので新しい<code>User</code>を作りそれぞれの<code>Thread</code>に関連付けましょう:</p>
<blockquote><p>$user = new User(); $user-&gt;username = 'jwage'; $board-&gt;Threads[0]-&gt;User</p>
</blockquote>
<p>= $user; $board-&gt;Threads[1]-&gt;User = $user;</p>
<p>これですべての変更を1つの呼び出しで保存できます。threadsと同じように新しいboardを保存します:</p>
<blockquote><p>// test.php</p>
</blockquote>
<p>// ... $board-&gt;save();</p>
<p>上記のコードを使うときに作成されるデータ構造を見てみましょう。投入したばかりのオブジェクトグラフの配列を出力するために<code>test.php</code>にコードを追加します:</p>
<blockquote><p>print\_r($board-&gt;toArray(true));</p>
<div class="alert tip-admonition bg-success text-light border"><table width="100%"><tr><td width="10" class="align-top"><i class="fas fa-question-circle mr-2"></i></td><td><p>レコードのデータを簡単にインスペクトできるように<code>Doctrine\_Record::toArray()</code>は<code>Doctrine_Record</code>インスタンスのすべてのデータを取り配列に変換します。これはリレーションを含めるかどうかを伝える<code>$deep</code>という名前の引数を受け取ります。この例では<code>Threads</code>のデータを含めたいので{[true]}を指定しました。</p>
</td></tr></table></div>
</blockquote>
<p>ターミナルで<code>test.php</code>を実行すると次の内容が表示されます:</p>
<blockquote><p>$ php test.php Array ( [id] =&gt; 2 [name] =&gt; Some board [description] =&gt;</p>
</blockquote>
<p>[Threads] =&gt; Array ( [0] =&gt; Array ( [id] =&gt; 3 [user\_id] =&gt; 1
[board\_id] =&gt; 2 [title] =&gt; new thread 1 [updated] =&gt; [closed] =&gt; [User]
=&gt; Array ( [id] =&gt; 1 [is\_active] =&gt; 1 [is\_super\_admin] =&gt; 0
[first\_name] =&gt; [last\_name] =&gt; [username] =&gt; jwage [password] =&gt;
[type] =&gt; [created\_at] =&gt; 2009-01-20 16:41:57 [updated\_at] =&gt;
2009-01-20 16:41:57 )</p>
<div class="console"><pre><code class="console">)

=> Array
(
    [id] => 4
    [user_id] => 1
    [board_id] => 2
    [title] => new thread 2
    [updated] => 
    [closed] => 
    [User] => Array
        (
            [id] => 1
            [is_active] => 1
            [is_super_admin] => 0
            [first_name] => 
            [last_name] => 
            [username] => jwage
            [password] => 
            [type] => 
            [created_at] => 2009-01-20 16:41:57
            [updated_at] => 2009-01-20 16:41:57
        )

)</code></pre></div>
<p>)</p>
<blockquote><p><strong>NOTE</strong>
Doctrine内部でautoincrementの主キーと外部キーが自動的に設定されることに注意してください。主キーと外部キーの設定に悩む必要はまったくありません！</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">外部キーのアソシエーション<i class="fas fa-link"></i></a></h2>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">一対一<i class="fas fa-link"></i></a></h3>
<p>一対一のリレーションは最も基本的なリレーションでしょう。次の例ではリレーションが一対一である<code>User</code>と<code>Email</code>の2つのクラスを考えます。</p>
<p>最初に<code>Email</code>クラスを見てみましょう。一対一のリレーションをバインドしているので<code>hasOne()</code>メソッドを使用しています。<code>Email</code>クラスで外部キーのカラム(<code>user_id</code>)を定義する方法に注目してください。これは<code>Email</code>が<code>User</code>によって所有され他の方法がないという事実に基づいています。実際次の慣習
- 所有側のクラスで外部キーを設置することに従うべきです。</p>
<p>外部キー用に推奨される命名規約は:
<code>[tableName]_[primaryKey]</code>です。外部テーブルは'user'で主キーは'id'なので外部キーのカラムは'user\_id'と名付けました。</p>
<blockquote><p>// models/Email.php</p>
</blockquote>
<p>class Email extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('user\_id', 'integer');
$this-&gt;hasColumn('address', 'string', 150); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('User', array(
            'local' => 'user_id',
            'foreign' => 'id'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Email: columns: user\_id: integer address: string(150) relations: User:
local: user\_id foreign: id foreignType: one</p>
<div class="alert tip-admonition bg-success text-light border"><table width="100%"><tr><td width="10" class="align-top"><i class="fas fa-question-circle mr-2"></i></td><td><p>リレーションは自動的に反転して追加されるので、YAMLスキーマファイルを使用するとき反対端(<code>User</code>)でリレーションを指定することは必須ではありません。リレーションはクラスの名前から名付けられます。ですのでこの場合<code>User</code>側のリレーションは<code>Email</code>と呼ばれ<code>many</code>になります。これをカスタマイズしたい場合<code>foreignAlias</code>と<code>foreignType</code>オプションを使用できます。</p>
</td></tr></table></div>
<p><code>Email</code>クラスは<code>User</code>クラスとよく似ています。localとforeignカラムは<code>Email</code>クラスの定義と比較される<code>hasOne()</code>の定義に切り替えられることに注目してください。</p>
<blockquote><p>// models/User.php</p>
</blockquote>
<p>class User extends BaseUser { public function setUp() { parent::setUp();</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->hasOne('Email', array(
        'local' => 'id',
        'foreign' => 'user_id'
    )
);</code></pre></div>
<p>}</p>
<blockquote><p><strong>NOTE</strong>
<code>setUp()</code>メソッドをオーバーライドして<code>parent::setUp()</code>を呼び出していることに注目してください。これはYAMLもしくは既存のデータベースから生成された<code>BaseUser</code>クラスがメインの<code>setUp()</code>メソッドを持ちリレーションを追加するために<code>User</code>クラスでこのメソッドをオーバーライドしているからです。</p>
</blockquote>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>User: # ... relations: # ... Email: local: id foreign: user\_id</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">一対多と多対一<i class="fas fa-link"></i></a></h3>
<p>一対多と多対一のリレーションは一対一のリレーションとよく似ています。以前の章で見た推奨される慣習は一対多と多対一のリレーションにも適用されます。</p>
<p>次の例では2つのクラス:
<code>User</code>と<code>Phonenumber</code>があります。一対多のリレーションとして定義します(ユーザーは複数の電話番号を持つ)。繰り返しますが<code>Phonenumber</code>は<code>User</code>によって所有されるので<code>Phonenumber</code>クラスに外部キーを設置します。</p>
<blockquote><p>// models/User.php</p>
</blockquote>
<p>class User extends BaseUser { public function setUp() { parent::setUp();</p>
<div class="console"><pre><code class="console">// ...

<span class="noselect">$ </span>this->hasMany('Phonenumber as Phonenumbers', array(
        'local' => 'id',
        'foreign' => 'user_id'
    )
);</code></pre></div>
<p>}</p>
<p>// models/Phonenumber.php</p>
<p>class Phonenumber extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('user\_id', 'integer');
$this-&gt;hasColumn('phonenumber', 'string', 50); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('User', array(
            'local' => 'user_id',
            'foreign' => 'id'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>User: # ... relations: # ... Phonenumbers: type: many class: Phonenumber
local: id foreign: user\_id</p>
<p>Phonenumber: columns: user\_id: integer phonenumber: string(50)
relations: User: local: user\_id foreign: id</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">ツリー構造<i class="fas fa-link"></i></a></h3>
<p>ツリー構造は自己参照の外部キーのリレーションです。次の定義は階層データの概念の用語では隣接リスト(Adjacency
List)とも呼ばれます。</p>
<blockquote><p>// models/Task.php</p>
</blockquote>
<p>class Task extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('name', 'string', 100);
$this-&gt;hasColumn('parent\_id', 'integer'); }</p>
<div class="console"><pre><code class="console">public function setUp() 
{
    $this->hasOne('Task as Parent', array(
            'local' => 'parent_id',
            'foreign' => 'id'
        )
    );

    $this->hasMany('Task as Subtasks', array(
            'local' => 'id',
            'foreign' => 'parent_id'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Task: columns: name: string(100) parent\_id: integer relations: Parent:
class: Task local: parent\_id foreign: id foreignAlias: Subtasks</p>
<blockquote><p><strong>NOTE</strong>
上記の実装は純粋な例で階層データを保存し読み取るための最も効率的な方法ではありません。階層データを扱い推奨方法に関してはDoctrineに含まれる<code>NestedSet</code>ビヘイビアを確認してください。</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">テーブルのアソシエーションをジョインする<i class="fas fa-link"></i></a></h2>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">多対多<i class="fas fa-link"></i></a></h3>
<p>リレーショナルデータベースの背景知識があれば、多対多のアソシエーションを扱う方法になれているかもしれません:
追加のアソシエーションテーブルが必要です。</p>
<p>多対多のリレーションにおいて2つのコンポーネントの間のリレーションは常に集約関係でアソシエーションテーブルは両端で所有されます。ユーザーとグループの場合:
ユーザーが削除されているとき、ユーザーが所属するグループは削除されません。しかしながら、ユーザーとユーザーが所属するグループの間のアソシエーションが代わりに削除されています。これはユーザーとユーザーが所属するグループの間のリレーションを削除しますが、ユーザーとグループは削除しません。</p>
<p>ときにはユーザー/グループを削除するときアソシエーションテーブルの列を削除したくないことがあります。リレーションをアソシエーションコンポーネントに設定する(このケースでは<code>Groupuser</code>)
ことで明示的にこのビヘイビアをオーバーライドできます。</p>
<p>次の例ではリレーションが多対多として定義されているGroupsとUsersがあります。このケースでは<code>Groupuser</code>と呼ばれる追加クラスも定義する必要があります。</p>
<blockquote><p>class User extends BaseUser public function setUp() { parent::setUp();</p>
</blockquote>
<div class="console"><pre><code class="console">// ...

<span class="noselect">$ </span>this->hasMany('Group as Groups', array(
        'local' => 'user_id',
        'foreign' => 'group_id',
        'refClass' => 'UserGroup'
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>User: # ... relations: # ... Groups: class: Group local: user\_id</p>
</blockquote>
<p>foreign: group\_id refClass: UserGroup</p>
<blockquote><p><strong>NOTE</strong>
多対多のリレーションをセットアップするとき上記の<code>refClass</code>オプションは必須です。</p>
<p>models/Group.php</p>
</blockquote>
<p>class Group extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;setTableName('groups');
$this-&gt;hasColumn('name', 'string', 30); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasMany('User as Users', array(
            'local' => 'group_id',
            'foreign' => 'user_id',
            'refClass' => 'UserGroup'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Group: tableName: groups columns: name: string(30) relations: Users:
class: User local: group\_id foreign: user\_id refClass: UserGroup</p>
<blockquote><p><strong>NOTE</strong>
<code>group</code>は予約語であることにご注意ください。これが<code>setTableName</code>メソッドを使用してテーブルを<code>groups</code>にリネームする理由です。予約語がクォートでエスケープされるように他のオプションは<code>Doctrine::ATTR\_QUOTE_IDENTIFIER</code>属性を使用して識別子のクォート追加を有功にすることです。</p>
<p>nager-&gt;setAttribute(Doctrine\_Core::ATTR\_QUOTE\_IDENTIFIER, true);</p>
<p>models/UserGroup.php</p>
</blockquote>
<p>class UserGroup extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('user\_id', 'integer', null,
array( 'primary' =&gt; true ) );</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->hasColumn('group_id', 'integer', null, array(
        'primary' => true
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>UserGroup: columns: user\_id: type: integer primary: true group\_id:
type: integer primary: true</p>
<p>リレーションが双方向であることに注目してください。<code>User</code>は複数の<code>Group</code>を持ち<code>Group</code>は複数の<code>User</code>を持ちます。Doctrineで多対多のリレーションを完全に機能させるためにこれは必須です。</p>
<p>新しいモデルで遊んでみましょう。ユーザーを作成しこれにいくつかのグループを割り当てます。最初に新しい<code>User</code>インス場合も考えてみましょう。注文テーブルが実在する製品の注文のみが含まれることを保証したい場合を考えます。ですので製品テーブルを参照する注文テーブルで外部キー制約を定義します:</p>
<blockquote><p>// models/Order.php</p>
</blockquote>
<p>class Order extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;setTableName('orders');
$this-&gt;hasColumn('product\_id', 'integer'); $this-&gt;hasColumn('quantity',
'integer'); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('Product', array(
            'local' => 'product_id',
            'foreign' => 'id'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Order: tableName: orders columns: product\_id: integer quantity: integer
relations: Product: local: product\_id foreign: id</p>
<blockquote><p><strong>NOTE</strong>
外部キーを含むクエリを発行するときに最適なパフォーマンスを保証するために外部キーのカラムのインデックスは自動的に作成されます。</p>
</blockquote>
<p><code>Order</code>クラスがエクスポートされるとき次のSQLが実行されます:</p>
<blockquote><p>CREATE TABLE orders ( id integer PRIMARY KEY auto\_increment,</p>
</blockquote>
<p>product\_id integer REFERENCES products (id), quantity integer, INDEX
product\_id\_idx (product\_id) )</p>
<p><code>product</code>テーブルに現れない<code>product_id</code>で<code>orders</code>を作成するのは不可能です。</p>
<p>この状況においてordersテーブルは参照するテーブルでproductsテーブルはは参照されるテーブルです。同じように参照と参照されるカラムがあります。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">外部キーの名前<i class="fas fa-link"></i></a></h3>
<p>Doctrineでリレーションを定義し外部キーがデータベースで作成されるとき、Doctrineは外部キーの名前をつけようとします。ときには、その名前が望んだものとは違うことがあるのでリレーションのセットアップで<code>foreignKeyName</code>オプションを使うことで名前をカスタマイズできます。</p>
<blockquote><p>// models/Order.php</p>
</blockquote>
<p>class Order extends Doctrine\_Record { // ...</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('Product', array(
            'local' => 'product_id',
            'foreign' => 'id',
            'foreignKeyName' => 'product_id_fk'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。YAMLの詳細は[doc
yaml-schema-files :name]の章で読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Order: # ... relations: Product: local: product\_id foreign: id
foreignKeyName: product\_id\_fk</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">整合アクション<i class="fas fa-link"></i></a></h3>
<p><strong>CASCADE</strong></p>
<p>親テーブルから列を削除もしくは更新しコテーブルでマッチするテーブルを自動的に削除もしくは更新します。<code>ON
DELETE CASCADE</code>と<code>ON UPDATE
CASCADE</code>の両方がサポートされます。2つのテーブルの間では、親テーブルもしくは子テーブルの同じカラムで振る舞う<code>ON
UPDATE CASCADE</code>句を定義すべきではありません。</p>
<p><strong>SET NULL</strong></p>
<p>親テーブルから列を削除もしは更新し子テーブルで外部キーカラムを<code>NULL</code>に設定します。外部キーカラムが<code>NOT
NULL</code>修飾子が指定されない場合のみこれは有効です。<code>ON DELETE SET
NULL</code>と<code>ON UPDATE SET NULL</code>句の両方がサポートされます。</p>
<p><strong>NO ACTION</strong></p>
<p>標準のSQLにおいて、<code>NO
ACTION</code>はアクションが行われないことを意味し、具体的には参照されるテーブルで関連する外部キーの値が存在する場合、主キーの値を削除するもしくは更新する処理が許可されません。</p>
<p><strong>RESTRICT</strong></p>
<p>親テーブルに対する削除もしくは更新オペレーションを拒否します。<code>NO
ACTION</code>と<code>RESTRICT</code>は<code>ON DELETE</code>もしくは<code>ON
UPDATE</code>句を省略するのと同じです。</p>
<p><strong>SET DEFAULT</strong></p>
<p>次の例において<code>User</code>と<code>Phonenumber</code>の2つのクラスのリレーションを一対多に定義します。<code>onDelete</code>カスケードアクションで外部キーの制約も追加します。このことは<code>user</code>が削除されるたびに関連する<code>phonenumbers</code>も削除されることを意味します。</p>
<blockquote><p><strong>NOTE</strong>
上記で示されている整合性制約は大文字小文字を区別しスキーマで定義するときは大文字でなければなりません。下記のコードは削除カスケードが使用されるデータベース削除の例です。</p>
<p>ss Phonenumber extends Doctrine\_Record { // ...</p>
</blockquote>
<div class="console"><pre><code class="console">public function setUp()
{
    parent::setUp();

    // ...

    $this->hasOne('User', array(
            'local' => 'user_id',
            'foreign' => 'id',
            'onDelete' => 'CASCADE'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Phonenumber: # ... relations: # ... User: local: user\_id foreign: id
onDelete: CASCADE</p>
<blockquote><p><strong>NOTE</strong>
外部キーがあるところで整合性制約がおかれていることに注目してください。整合性制約がデータベースのプロパティにエクスポートされるためにこれは必須です。</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">インデックス<i class="fas fa-link"></i></a></h1>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">はじめに<i class="fas fa-link"></i></a></h2>
<p>インデックスは特定のカラムの値を持つ列を素早く見つけるために使われます。インデックスなしでは、データベースは最初の列から始め関連する列をすべて見つけるためにテーブル全体を読み込まなければなりません。</p>
<p>テーブルが大きくなるほど、時間がかかります。テーブルが問題のカラム用のインデックスを持つ場合、データベースはデータをすべて見ることなくデータの中ほどで位置を素早く決定できます。テーブルが1000の列を持つ場合、これは列を1つづつ読み込むよりも少なくとも100倍以上速いです。</p>
<p>インデックスはinsertとupdateを遅くなるコストがついてきます。しかしながら、一般的に
SQLのwhere条件で使われるフィールドに対して<strong>常に</strong>インデックスを使うべきです。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">インデックスを追加する<i class="fas fa-link"></i></a></h2>
<p><code>Doctrine_Record::index</code>を使用してインデックスを追加できます。インデックスをnameという名前のフィールドに追加するシンプルな例です:</p>
<blockquote><p><strong>NOTE</strong>
次のインデックスの例はDoctrineの環境に実際に追加することは想定されていません。これらはインデックス追加用のAPIを示すためだけを意図しています。</p>
<p>ss IndexTest extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('name', 'string');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->index('myindex', array(
        'fields' => array('name')
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>IndexTest: columns: name: string indexes: myindex: fields: [name]</p>
</blockquote>
<p><code>name</code>という名前のフィールドにマルチカラムインデックスを追加する例です:</p>
<blockquote><p>class MultiColumnIndexTest extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('name', 'string');
$this-&gt;hasColumn('code', 'string');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->index('myindex', array(
        'fields' => array('name', 'code')
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を見ることができます:</p>
<blockquote><p>MultiColumnIndexTest: columns: name: string code: string indexes:</p>
</blockquote>
<p>myindex: fields: [name, code]</p>
<p>同じテーブルで複数のインデックスを追加する例です:</p>
<blockquote><p>class MultipleIndexTest extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('name', 'string');
$this-&gt;hasColumn('code', 'string'); $this-&gt;hasColumn('age', 'integer');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->index('myindex', array(
        'fields' => array('name', 'code')
    )
);

<span class="noselect">$ </span>this->index('ageindex', array(
        'fields' => array('age')
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>MultipleIndexTest: columns: name: string code: string age: integer</p>
</blockquote>
<p>indexes: myindex: fields: [name, code] ageindex: fields: [age]</p>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">インデックスオプション<i class="fas fa-link"></i></a></h2>
<p>Doctrineは多くのインデックスオプションを提供します。これらの一部はデータベース固有のものです。利用可能なオプションの全リストは次の通りです:</p>
<p>\&nbsp; 名前 \&nbsp; 説明 \ \ <code>sorting</code> \
文字列の値が'ASC'もしくは'DESC'の値を取れるか \ \ <code>length</code> \
インデックスの長さ(一部のドライバのみサポート)。 \ \ <code>primary</code>
\ インデックスがプライマリインデックスであるか。 \ \ <code>type</code>
\
文字列の値で'unique'、'fulltext'、'gist'もしくは'gin'が許可されるか\</p>
<p>nameカラムでユニークインデックスを作る方法の例は次の通りです。</p>
<blockquote><p>class MultipleIndexTest extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('name', 'string');
$this-&gt;hasColumn('code', 'string'); $this-&gt;hasColumn('age', 'integer');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->index('myindex', array(
        'fields' => array(
            'name' => array(
                'sorting' => 'ASC',
                'length'  => 10),
                'code'
            ),
        'type' => 'unique',
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。YAMLの詳細は[doc
yaml-schema-files :name]の章で読むことができます:</p>
<blockquote><p>MultipleIndexTest: columns: name: string code: string age: integer</p>
</blockquote>
<p>indexes: myindex: fields: name: sorting: ASC length: 10 code: - type:
unique</p>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">特別なインデックス<i class="fas fa-link"></i></a></h2>
<p>Doctrineは多くの特別なインデックスをサポートします。これらにはMysqlのFULLTEXTとPgsqlのGiSTインデックスが含まれます。次の例では'content'フィールドに対してMysqlのFULLTEXTインデックスを定義します。</p>
<blockquote><p>// models/Article.php</p>
</blockquote>
<p>class Article extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('name', 'string', 255);
$this-&gt;hasColumn('content', 'string');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->option('type', 'MyISAM');

<span class="noselect">$ </span>this->index('content', array(
        'fields' => array('content'),
        'type'   => 'fulltext'
    )
);</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Article: options: type: MyISAM columns: name: string(255) content:
string indexes: content: fields: [content] type: fulltext</p>
<blockquote><p><strong>NOTE</strong>
テーブルの型を<code>MyISAM</code>に設定していることに注目してください。これは<code>fulltext</code>インデックス型は<code>MyISAM</code>でのみサポートされるため<code>InnoDB</code>などを使う場合はエラーを受け取るからです。</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">チェック<i class="fas fa-link"></i></a></h1>
<p><code>Doctrine_Record</code>の<code>check()</code>メソッドを使用することで任意の<code>CHECK</code>制約を作成できます。最後の例では価格がディスカウント価格よりも常に高いことを保証するために制約を追加します。</p>
<blockquote><p>// models/Product.php</p>
</blockquote>
<p>class Product extends Doctrine\_Record { public function
setTableDefinition() { // ...</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->check('price > discounted_price');


..</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Product: # ... checks: price\_check: price &gt; discounted\_price</p>
<p>生成されるSQL(pgsql):</p>
<blockquote><p>CREATE TABLE product ( id INTEGER, price NUMERIC, discounted\_price</p>
</blockquote>
<p>NUMERIC, PRIMARY KEY(id), CHECK (price &gt;= 0), CHECK (price &lt;= 1000000),
CHECK (price &gt; discounted\_price))</p>
<blockquote><p><strong>NOTE</strong>
データベースの中には<code>CHECK</code>制約をサポートしないものがあります。この場合Doctrineはチェック制約の作成をスキップします。</p>
</blockquote>
<p>Doctrineバリデータが定義で有効な場合はレコードが保存されるとき価格が常にゼロ以上であることも保証されます。</p>
<p>トランザクションの範囲で保存される価格の中にゼロよりも小さいものがある場合、Doctrineは<code>Doctrine\_Validator_Exception</code>を投げトランザクションを自動的にロールバックします。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">テーブルオプション<i class="fas fa-link"></i></a></h1>
<p>Doctrineはさまざまなテーブルオプションを提供します。すべてのテーブルオプションは<code>Doctrine_Record::option</code>関数を通して設定できます。</p>
<p>例えばMySQLを使用しINNODBテーブルを利用したい場合は次のようにできます:</p>
<blockquote><p>class MyInnoDbRecord extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('name', 'string');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->option('type', 'INNODB');</code></pre></div>
<p>}</p>
<p>YAMLフォーマットの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を見ることができます:</p>
<blockquote><p>MyInnoDbRecord: columns: name: string options: type: INNODB</p>
</blockquote>
<p>次の例では照合順序と文字集合のオプションを設定します:</p>
<blockquote><p>class MyCustomOptionRecord extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('name', 'string');</p>
<div class="console"><pre><code class="console"><span class="noselect">$ </span>this->option('collate', 'utf8_unicode_ci');
<span class="noselect">$ </span>this->option('charset', 'utf8');</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例です。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p>MyCustomOptionRecord: columns: name: string options: collate:</p>
</blockquote>
<p>utf8\_unicode\_ci charset: utf8</p>
<p>特定のデータベース(Firebird、MySqlとPostgreSQL)でcharsetオプションを設定しても無意味でDoctrineがデータを適切に返すのには不十分であることがあります。これらのデータベースに対して、データベース接続の<code>setCharset</code>関数を使うこともお勧めします:</p>
<blockquote><p>$conn = Doctrine\_Manager::connection(); $conn-&gt;setCharset('utf8');</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">レコードフィルター<i class="fas fa-link"></i></a></h1>
<p>Doctrineはモデルを定義するときにレコードフィルターを添付する機能を持ちます。レコードフィルターは無効なモデルのプロパティにアクセスするときに起動されます。ですのでこれらのフィルターの1つを使うことを通してプロパティをモデルに追加することが本質的に可能になります。</p>
<p>フィルターを添付するにはこれをモデル定義の<code>setUp()</code>メソッドに追加することだけが必要です:</p>
<blockquote><p>class User extends Doctrine\_Record { public function</p>
</blockquote>
<p>setTableDefinition() { $this-&gt;hasColumn('username', 'string', 255);
$this-&gt;hasColumn('password', 'string', 255); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('Profile', array(
        'local' => 'id',
        'foreign' => 'user_id'
    ));
    $this->unshiftFilter(new Doctrine_Record_Filter_Compound(array('Profile')));
}</code></pre></div>
<p>}</p>
<p>class Profile extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('user\_id', 'integer');
$this-&gt;hasColumn('first\_name', 'string', 255);
$this-&gt;hasColumn('last\_name', 'string', 255); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('Profile', array(
        'local' => 'user_id',
        'foreign' => 'id'
    ));
}</code></pre></div>
<p>}</p>
<p>上記の例のコードによって<code>User</code>のインスタンスを使うとき<code>Profile</code>リレーションのプロパティに簡単にアクセスできます。次のコードは例です:</p>
<blockquote><p>$user = Doctrine\_Core::getTable('User') -&gt;createQuery('u')</p>
</blockquote>
<p>-&gt;innerJoin('u.Profile p') -&gt;where('p.username = ?', 'jwage')
-&gt;fetchOne();</p>
<p>echo $user-&gt;first\_name . ' ' . $user-&gt;last\_name;</p>
<p><code>first\_name</code>と<code>last_name</code>プロパティに問い合わせるときこれらは<code>$user</code>インスタンスに存在しないのでこれらは<code>Profile</code>リレーションにフォワードされます。これは次の内容を行ったこととまったく同じです:</p>
<blockquote><p>echo $user-&gt;Profile-&gt;first\_name . ' ' . $user-&gt;Profile-&gt;last\_name;</p>
</blockquote>
<p>独自のレコードフィルターをとても簡単に書くこともできます。必要なことは<code>Doctrine\_Record_Filter</code>を継承し<code>filterSet()</code>と<code>filterGet()</code>メソッドを実装するクラスを作ることです。例は次の通りです:</p>
<blockquote><p>class MyRecordFilter extends Doctrine\_Record\_Filter { public function</p>
</blockquote>
<p>filterSet(Doctrine\_Record $record, $name, $value) { //
プロパティをトライしてセットする</p>
<div class="console"><pre><code class="console">throw new Doctrine_Record_UnknownPropertyException(sprintf('Unknown record property / related component "%s" on "%s"', $name, get_class($record)));


ic function filterGet(Doctrine_Record, $name)

// プロパティをトライしてゲットする

throw new Doctrine_Record_UnknownPropertyException(sprintf('Unknown record property / related component "%s" on "%s"', $name, get_class($record)));</code></pre></div>
<p>}</p>
<p>これでフィルターをモデルに追加できます:</p>
<blockquote><p>class MyModel extends Doctrine\_Record { // ...</p>
</blockquote>
<div class="console"><pre><code class="console">public function setUp()
{
    // ...

    $this->unshiftFilter(new MyRecordFilter());
}</code></pre></div>
<p>}</p>
<blockquote><p><strong>NOTE</strong>
<code>filterSet()</code>もしくは<code>filterGet()</code>がプロパティを見つけられない場合、例外クラスの<code>Doctrine_Record_UnknownPropertyException</code>のインスタンスが投げられていることをかならず確認してください。</p>
</blockquote>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">遷移的な永続化<i class="fas fa-link"></i></a></h1>
<p>Doctrineはデータベースとアプリケーションレベルでカスケーディングオペレーションを提供します。このセクションではアプリケーションとデータベースレベルの両方でセットアップする詳細な方法を説明します。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">アプリケーションレベルのカスケード<i class="fas fa-link"></i></a></h2>
<p>とりわけオブジェクトグラフを扱うとき、個別のオブジェクトの保存と削除はとても退屈です。Doctrineはアプリケーションレベルでオペレーションのカスケード機能を提供します。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">保存カスケード<i class="fas fa-link"></i></a></h3>
<p>デフォルトでは<code>save()</code>オペレーションは関連オブジェクトに既にカスケードされていることにお気づきかもしれません。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h3 class="section-header"><a href="#">削除カスケード<i class="fas fa-link"></i></a></h3>
<p>Doctrineは2番目のカスケードスタイル:
deleteを提供します。<code>save()</code>カスケードとは異なり、<code>delete</code>カスケードは次のコードスニペットのように明示的に有効にする必要があります:</p>
<blockquote><p>// models/User.php</p>
</blockquote>
<p>class User extends BaseUser { // ...</p>
<div class="console"><pre><code class="console">public function setUp()
{
    parent::setup();

    // ...

    $this->hasMany('Address as Addresses', array(
            'local' => 'id',
            'foreign' => 'user_id',
            'cascade' => array('delete')
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットでの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>User: # ... relations: # ... Addresses: class: Address local: id
foreign: user\_id cascade: [delete]</p>
<p>アプリケーションレベルで関連オブジェクトにカスケードされるオペレーションを指定するために<code>cascade</code>オプションが使われます。</p>
<blockquote><p><strong>NOTE</strong>
現在サポートされる値は<code>delete</code>のみであることにご注意ください。より多くのオプションは将来のDoctrineのリリースで追加されます。</p>
</blockquote>
<p>上記の例において、Doctrineは関連する<code>Address</code>に<code>User</code>の削除をカスケードします。次の説明は<code>$record-&gt;delete()</code>を通してレコードを削除する際の一般的な手続きです:</p>
<p><strong>1.</strong>
Doctrineは適用する必要のある削除カスケードが存在するかリレーションを探します。削除カスケードが存在しない場合、3に移動します)。</p>
<p><strong>2.</strong>
指定された削除カスケードを持つそれぞれのリレーションに対して、Doctrineはカスケードのターゲットであるオブジェクトがロードされることを確認します。このことはDoctrineは関連オブジェクトがまだロードされていない場合データベースから関連オブジェクトが取得することを意味します。(例外:
すべてのオブジェクトがロードされていることを確認するために多くの値を持つアソシエーションはデータベースから再取得されます)。それぞれの関連オブジェクトに対して、ステップ1に進みます)。</p>
<p><strong>3.</strong>
Doctrineは参照照合性を維持しながらすべての削除を並べ替え最も効果的な方法で実行します。</p>
<p>この説明から1つのことがすぐに明らかになります:
アプリケーションレベルのカスケードはオブジェクトレベルで行われ、参加しているオブジェクトが利用可能にすることを行うために1つのオブジェクトから別にオブジェクトにオペレーションがカスケードされることを意味します。</p>
<p>このことは重要な意味を示します:</p>
<ul><li class="dash"> 関連の照合順序でたくさんのオブジェクトがあるとき多くの値を持つアソシエーションではアプリケーションレベルの削除カスケードはうまく実行されませんこれらがデータベースから取得される必要があるためで、実際の削除はとても効率的です)。</li>
<li class="dash"> アプリケーションレベルの削除カスケードはデータベースレベルのカスケードが行うようにオブジェクトのライフサイクルをスキップしません(次の章を参照)。それゆえ登録されたすべてのイベントリスナーと他のコールバックメソッドはアプリケーションレベルのカスケードで適切に実行されます。</li>
</ul>

<hr />
<a class="section-anchor" id="" name=""></a><h2 class="section-header"><a href="#">データベースレベルのカスケード<i class="fas fa-link"></i></a></h2>
<p>データベースレベルでカスケードオペレーションはとても効率的にできるものがあります。もっともよい例は削除カスケードです。</p>
<p>次のことを除いて一般的にデータベースレベルの削除カスケードはアプリケーションレベルよりも望ましいです:</p>
<ul><li class="dash"> データベースがデータベースレベルのカスケードをサポートしない(MySqlでMYISAMテーブルを使うとき)。</li>
<li class="dash"> オブジェクトライフサイクルをリスニングするリスナーがありこれらを起動させたい。</li>
</ul>

<p>データベースレベルの削除カスケードは外部キー制約に適用されます。それゆえこれらは外部キーを所有するリレーション側で指定されます。上記から例を拾うと、データベースレベルのカスケードの定義は次のようになります:</p>
<blockquote><p>// models/Address.php</p>
</blockquote>
<p>class Address extends Doctrine\_Record { public function
setTableDefinition() { $this-&gt;hasColumn('user\_id', 'integer');
$this-&gt;hasColumn('address', 'string', 255); $this-&gt;hasColumn('country',
'string', 255); $this-&gt;hasColumn('city', 'string', 255);
$this-&gt;hasColumn('state', 'string', 2); $this-&gt;hasColumn('postal\_code',
'string', 25); }</p>
<div class="console"><pre><code class="console">public function setUp()
{
    $this->hasOne('User', array(
            'local' => 'user_id',
            'foreign' => 'id',
            'onDelete' => 'CASCADE'
        )
    );
}</code></pre></div>
<p>}</p>
<p>YAMLフォーマットの同じ例は次の通りです。[doc yaml-schema-files
:name]の章でYAMLの詳細を詳しく読むことができます:</p>
<blockquote><p># schema.yml</p>
</blockquote>
<p>Address: columns: user\_id: integer address: string(255) country:
string(255) city: string(255) state: string(2) postal\_code: string(25)
relations: User: local: user\_id foreign: id onDelete: CASCADE</p>
<p>Doctrineがテーブルを作成するとき<code>onDelete</code>オプションは適切なDDL/DMLステートメントに翻訳されます。</p>
<blockquote><p><strong>NOTE</strong> <code>'onDelete' =&gt;
'CASCADE'</code>がAddressクラスで指定されることに注目してください。Addressは外部キー(<code>user_id</code>)を所有するのでデータベースレベルのカスケードは外部キーに適用されます。</p>
</blockquote>
<p>現在、2つのデータベースレベルのカスケードスタイルは<code>onDelete</code>と<code>onUpdate</code>に対してのみです。Doctrineがテーブルを作成するとき両方とも外部キーを所有する側で指定されデータベーススキーマに適用されます。</p>
<hr />
<a class="section-anchor" id="" name=""></a><h1 class="section-header"><a href="#">まとめ<i class="fas fa-link"></i></a></h1>
<p>これでDoctrineのモデルを定義するすべての方法を知りました。アプリケーションで[doc
work-with-models モデルと連携する]方法を学ぶ準備ができています。</p>
<p>これはとても大きなトピックなので、少し休憩を取り、マウンテンデューを飲んで[doc
working-with-models 次の章]にすぐに戻ってください。</p>
<p></p>
            </main>

        
        <button id="back-to-top" title="Go to top">Top</button>

        <script
          src="https://code.jquery.com/jquery-3.3.1.min.js"
          integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
          crossorigin="anonymous"></script>

        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>

        <script
            src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script>

        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.6.0"></script>

        <script id="instantsearch-template" type="text/template">
            
    <a href="{{url}}" class="list-group-item list-group-item-action flex-column align-items-start">
        <div class="d-flex w-100 justify-content-between">
            <h5 class="mb-1">{{{_highlightResult.projectName.value}}}: {{{_highlightResult.h1.value}}}</h5>
        </div>

        {{#h2}}
            <p class="mb-1">
                <i class="far fa-arrow-alt-circle-right text-primary"></i>

                {{{_highlightResult.h2.value}}}

                {{#h3}}
                    > {{{_highlightResult.h3.value}}}
                {{/h3}}

                {{#h4}}
                    > {{{_highlightResult.h4.value}}}
                {{/h4}}

                {{#h5}}
                    > {{{_highlightResult.h5.value}}}
                {{/h5}}
            </p>
        {{/h2}}

        {{#content}}
            <div class="content p-2 rounded" style="background-color: rgba(0,0,0,.125);">
                {{{_highlightResult.content.value}}}
            </div>
        {{/content}}
    </a>

        </script>

        <script src="https://cdn.ravenjs.com/3.24.2/raven.min.js" crossorigin="anonymous"></script>

        <script type="text/javascript">
            Raven.config('https://09ce137590054cfd8f0b7e9324d6ec14@sentry.io/1197701').install()
        </script>

        <script src="https://staging.doctrine-project.org/js/main.js?4138a7"></script>
        <script src="https://staging.doctrine-project.org/js/search.js?493399"></script>

        <script type="text/javascript">
            var projectSlug = '';
            var versionSlug = 'latest';

            var searchBoxSettings = {
                container: '#search-box',
                placeholder: 'Search'
            };

            new Main();

            new Search(projectSlug, versionSlug, searchBoxSettings);

            function googleAnalyticsEvent(eventCategory, eventAction, eventLabel, eventValue, fieldsObject) {
                                console.log(eventCategory, eventAction, eventLabel, eventValue, fieldsObject);
                            }

            function googleTranslateElementInit() {
                $('#google_translate_element').html('');

                new google.translate.TranslateElement(
                    {pageLanguage: 'en'}, 'google_translate_element'
                );

                $('#google_translate_element select').on('change', function() {
                    var language = $('#google_translate_element select option:selected').text();

                    googleAnalyticsEvent('Translate', 'click', language);
                });
            }
        </script>

        <script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>

        
        
            </body>
</html>
